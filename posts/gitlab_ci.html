<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>如何使用 GitLab CI/CD 自动化 Docker 镜像打包和部署</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/352a7f6477311b3a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/352a7f6477311b3a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/IwRpAjqXkA_d6bS-Gv3M9/_buildManifest.js" defer=""></script><script src="/_next/static/IwRpAjqXkA_d6bS-Gv3M9/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">如何使用 GitLab CI/CD 自动化 Docker 镜像打包和部署</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2023-05-25">May 25, 2023</time></div><div><p>最近在公司参与一个后端项目，当有功能更新或者 bug 修复时，需要重新打包镜像并部署到 k8s 集群中。这个过程比较繁琐，需要手动打包镜像、手动推送镜像、手动部署。这个过程中，有很多重复的操作，而且容易出错。因此，我考虑使用 GitLab CI/CD 来自动化这个过程。本文将介绍如何使用 GitLab CI/CD 来自动化打包镜像、推送镜像、部署应用。</p>
<p>在讨论如何使用 GitLab CI/CD 之前，有两个问题需要我们思考：什么时候触发打镜像、推送镜像、部署应用的流程？打镜像应该打什么标签呢？当有代码合并到 main 分支时触发该流程显然不太合理，因为有些代码只是一些小的修改，例如改了 readme 中的一个 typo，这种情况下没必要重新部署应用。打镜像应该打什么标签也是一个问题，总是打 latest 显然也不太合理，因为我们可能需要回滚到之前的版本，所以我们需要打上版本号。通常，项目的包管理工具都有一些配置项去管理版本号，例如 npm 的 package.json 中的 version 字段，rust 的 Cargo.toml 中的 version 字段，我们可以使用这些配置项来管理版本号，然后在打镜像时将版本号作为镜像的 tag。</p>
<p>基于以上考虑，我们可以确定以下流程：</p>
<p>当代码合并到 main 分支时，检查版本号是否有更新，如果有则触发打标签，打包并推送镜像，部署应用。</p>
<p>检查版本号是否有更新的方法可以使用 git tag 来实现。我们可以给所有历史版本都使用 git tag 打上标签，然后检查当前代码最新版本号的 tag 是否已在远端存在。如果不存在，说明版本号有更新，此时触发上述流程。</p>
<p>为了提高 CI 的可维护性，我们可以将上述流程拆分成多个 job。例如：</p>
<ul>
<li>打标签</li>
<li>打包并推送镜像</li>
<li>部署应用</li>
</ul>
<p>其中，打标签的难点在于如何查询当前版本号对应的 tag 是否在远端存在，以及如何向远端推送 tag。因为这些代码是跑在 Runner 上的，没办法交互式输入用户名和密码，也很难通过配置 ssh key 的方式获得远端仓库的读写权限（主要是因为我用的是 <a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">在 docker 容器中跑 CI/CD 的模式</a> 这个模式）。不过，我们可以参考 <a href="https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html#bot-users-for-projects">https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html#bot-users-for-projects</a> 。下面是一个可能的脚本实现（以 poetry 管理的 python 项目为例）：</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 仅在 git 未配置时进行配置</span>
git config user.name >&#x26;- || git config user.name <span class="hljs-string">"ci-bot"</span>
git config user.email >&#x26;- || git config user.email <span class="hljs-string">"ci-bot@xxx.com"</span>
git config remote.gitlab_origin.url >&#x26;- || git remote add gitlab_origin https://oauth2:<span class="hljs-variable">$ACCESS_TOKEN</span>@gitlab.xxx
git remote -v

poetry_version=$(poetry version) <span class="hljs-comment"># e.g. foo 0.1.0</span>
project_name=$(poetry version | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">' '</span> -f1)  <span class="hljs-comment"># 获取版本字符串中的第一个字符串，如 foo</span>
project_version=$(poetry version | <span class="hljs-built_in">cut</span> -d<span class="hljs-string">' '</span> -f2) <span class="hljs-comment"># 获取版本字符串中的第二个字符串，如 0.1.0</span>

tag_name=<span class="hljs-string">"<span class="hljs-variable">$project_name</span>-<span class="hljs-variable">$project_version</span>"</span>

<span class="hljs-comment"># 检查标签是否已存在于远端</span>
<span class="hljs-keyword">if</span> git ls-remote --tags --exit-code gitlab_origin <span class="hljs-string">"<span class="hljs-variable">$tag_name</span>"</span> > /dev/null 2>&#x26;1; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Tag <span class="hljs-variable">$tag_name</span> already exists in remote, skipping"</span>
<span class="hljs-keyword">else</span>
    git tag -a <span class="hljs-string">"<span class="hljs-variable">$tag_name</span>"</span> -f -m <span class="hljs-string">"Tagging <span class="hljs-variable">$tag_name</span>"</span>
    git push gitlab_origin <span class="hljs-string">"<span class="hljs-variable">$tag_name</span>"</span>
<span class="hljs-keyword">fi</span>
</code></pre>
<p>打包并推送镜像的难点在于如何在 Runner 上使用 Docker CLI。我们可以选择使用 Docker-in-Docker 的方式来完成该操作，具体可以参考 <a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker">https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker</a></p>
<p>对于部署应用，我们没有太多其他的要点可以讨论。如果使用 Helm 部署的话，建议在测试环境中部署 latest 镜像，而在生产环境中部署指定版本号的镜像。在测试环境中，可以使用 <code>helm delete</code> 命令删除已有应用，然后使用 <code>helm install</code> 命令来部署该应用。因为测试环境每次都是使用 latest 镜像，对于更新操作，如果用 <code>helm upgrade</code> 命令，k8s 会认为不需要进行更新，deployment 的状态没有发生改变。对于生产环境，可以使用 <code>helm upgrade</code> 命令来更新应用，因为有更新时我们总是会更新 charts 中的版本号。</p>
<p>总的来说，使用 GitLab CI/CD 可以完全自动化打包、推送镜像及部署应用的流程，并减少出错概率。</p></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"gitlab_ci","contentHtml":"\u003cp\u003e最近在公司参与一个后端项目，当有功能更新或者 bug 修复时，需要重新打包镜像并部署到 k8s 集群中。这个过程比较繁琐，需要手动打包镜像、手动推送镜像、手动部署。这个过程中，有很多重复的操作，而且容易出错。因此，我考虑使用 GitLab CI/CD 来自动化这个过程。本文将介绍如何使用 GitLab CI/CD 来自动化打包镜像、推送镜像、部署应用。\u003c/p\u003e\n\u003cp\u003e在讨论如何使用 GitLab CI/CD 之前，有两个问题需要我们思考：什么时候触发打镜像、推送镜像、部署应用的流程？打镜像应该打什么标签呢？当有代码合并到 main 分支时触发该流程显然不太合理，因为有些代码只是一些小的修改，例如改了 readme 中的一个 typo，这种情况下没必要重新部署应用。打镜像应该打什么标签也是一个问题，总是打 latest 显然也不太合理，因为我们可能需要回滚到之前的版本，所以我们需要打上版本号。通常，项目的包管理工具都有一些配置项去管理版本号，例如 npm 的 package.json 中的 version 字段，rust 的 Cargo.toml 中的 version 字段，我们可以使用这些配置项来管理版本号，然后在打镜像时将版本号作为镜像的 tag。\u003c/p\u003e\n\u003cp\u003e基于以上考虑，我们可以确定以下流程：\u003c/p\u003e\n\u003cp\u003e当代码合并到 main 分支时，检查版本号是否有更新，如果有则触发打标签，打包并推送镜像，部署应用。\u003c/p\u003e\n\u003cp\u003e检查版本号是否有更新的方法可以使用 git tag 来实现。我们可以给所有历史版本都使用 git tag 打上标签，然后检查当前代码最新版本号的 tag 是否已在远端存在。如果不存在，说明版本号有更新，此时触发上述流程。\u003c/p\u003e\n\u003cp\u003e为了提高 CI 的可维护性，我们可以将上述流程拆分成多个 job。例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e打标签\u003c/li\u003e\n\u003cli\u003e打包并推送镜像\u003c/li\u003e\n\u003cli\u003e部署应用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中，打标签的难点在于如何查询当前版本号对应的 tag 是否在远端存在，以及如何向远端推送 tag。因为这些代码是跑在 Runner 上的，没办法交互式输入用户名和密码，也很难通过配置 ssh key 的方式获得远端仓库的读写权限（主要是因为我用的是 \u003ca href=\"https://docs.gitlab.com/ee/ci/docker/using_docker_images.html\"\u003e在 docker 容器中跑 CI/CD 的模式\u003c/a\u003e 这个模式）。不过，我们可以参考 \u003ca href=\"https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html#bot-users-for-projects\"\u003ehttps://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html#bot-users-for-projects\u003c/a\u003e 。下面是一个可能的脚本实现（以 poetry 管理的 python 项目为例）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 仅在 git 未配置时进行配置\u003c/span\u003e\ngit config user.name \u003e\u0026#x26;- || git config user.name \u003cspan class=\"hljs-string\"\u003e\"ci-bot\"\u003c/span\u003e\ngit config user.email \u003e\u0026#x26;- || git config user.email \u003cspan class=\"hljs-string\"\u003e\"ci-bot@xxx.com\"\u003c/span\u003e\ngit config remote.gitlab_origin.url \u003e\u0026#x26;- || git remote add gitlab_origin https://oauth2:\u003cspan class=\"hljs-variable\"\u003e$ACCESS_TOKEN\u003c/span\u003e@gitlab.xxx\ngit remote -v\n\npoetry_version=$(poetry version) \u003cspan class=\"hljs-comment\"\u003e# e.g. foo 0.1.0\u003c/span\u003e\nproject_name=$(poetry version | \u003cspan class=\"hljs-built_in\"\u003ecut\u003c/span\u003e -d\u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e -f1)  \u003cspan class=\"hljs-comment\"\u003e# 获取版本字符串中的第一个字符串，如 foo\u003c/span\u003e\nproject_version=$(poetry version | \u003cspan class=\"hljs-built_in\"\u003ecut\u003c/span\u003e -d\u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e -f2) \u003cspan class=\"hljs-comment\"\u003e# 获取版本字符串中的第二个字符串，如 0.1.0\u003c/span\u003e\n\ntag_name=\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e$project_name\u003c/span\u003e-\u003cspan class=\"hljs-variable\"\u003e$project_version\u003c/span\u003e\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 检查标签是否已存在于远端\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e git ls-remote --tags --exit-code gitlab_origin \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e$tag_name\u003c/span\u003e\"\u003c/span\u003e \u003e /dev/null 2\u003e\u0026#x26;1; \u003cspan class=\"hljs-keyword\"\u003ethen\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Tag \u003cspan class=\"hljs-variable\"\u003e$tag_name\u003c/span\u003e already exists in remote, skipping\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n    git tag -a \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e$tag_name\u003c/span\u003e\"\u003c/span\u003e -f -m \u003cspan class=\"hljs-string\"\u003e\"Tagging \u003cspan class=\"hljs-variable\"\u003e$tag_name\u003c/span\u003e\"\u003c/span\u003e\n    git push gitlab_origin \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e$tag_name\u003c/span\u003e\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efi\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打包并推送镜像的难点在于如何在 Runner 上使用 Docker CLI。我们可以选择使用 Docker-in-Docker 的方式来完成该操作，具体可以参考 \u003ca href=\"https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker\"\u003ehttps://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e对于部署应用，我们没有太多其他的要点可以讨论。如果使用 Helm 部署的话，建议在测试环境中部署 latest 镜像，而在生产环境中部署指定版本号的镜像。在测试环境中，可以使用 \u003ccode\u003ehelm delete\u003c/code\u003e 命令删除已有应用，然后使用 \u003ccode\u003ehelm install\u003c/code\u003e 命令来部署该应用。因为测试环境每次都是使用 latest 镜像，对于更新操作，如果用 \u003ccode\u003ehelm upgrade\u003c/code\u003e 命令，k8s 会认为不需要进行更新，deployment 的状态没有发生改变。对于生产环境，可以使用 \u003ccode\u003ehelm upgrade\u003c/code\u003e 命令来更新应用，因为有更新时我们总是会更新 charts 中的版本号。\u003c/p\u003e\n\u003cp\u003e总的来说，使用 GitLab CI/CD 可以完全自动化打包、推送镜像及部署应用的流程，并减少出错概率。\u003c/p\u003e","title":"如何使用 GitLab CI/CD 自动化 Docker 镜像打包和部署","date":"2023-05-25"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"gitlab_ci"},"buildId":"IwRpAjqXkA_d6bS-Gv3M9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>