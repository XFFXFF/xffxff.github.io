<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>《Crafting Interpreters》阅读笔记（二）</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/ab65974685f462b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab65974685f462b8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/gQcfR_oSI5UIowtnKE0vz/_buildManifest.js" defer=""></script><script src="/_next/static/gQcfR_oSI5UIowtnKE0vz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">《Crafting Interpreters》阅读笔记（二）</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2021-10-17">October 17, 2021</time></div><div><p><a href="http://www.craftinginterpreters.com/">《Crafting Interpreters》</a>中 jlox（Part I 中用 java 实现的 Lox 语言）用了 recursive descent parsing 去实现 parser。为了偷懒，下面用 RD 代指 recursive descent parsing 这个方法。</p>
<h2>设计简易计算器</h2>
<p>假如我们现在要实现一个支持加减乘除的计算器，那 parser 应该怎么设计？</p>
<ul>
<li>并不是所有的输入都是支持的，比如输入“1 +/ 2”</li>
<li>不同运算符优先级不一样，考虑“1 + 2 * 3”，应该先算乘法，再算加法</li>
<li>当运算符优先级一样时，应该优先算靠左边的</li>
</ul>
<p>上面三条都是在定义或者限制计算器的语法规则，我们将语法规则用一套符号语言去表示。</p>
<pre><code>Expr -> Expr + Term     (1)
      | Expr - Term     (2)
      | Term            (3)
Term -> Term * Factor   (4)
      | Term / Factor   (5)
      | Factor          (6)
Factor -> Number        (7)
</code></pre>
<p>每一行表示一条语法规则，为了方便描述，给每条规则都标了号，这里一共有 7 条规则。上面的这套符号应该怎么理解呢？箭头左边的表达式可以转换成右边的表达式，“｜”表示逻辑或，比如说 Expr 可以展开成 Expr + Term， Expr - Term 和 Term 中的任何一个， 以"1 + 2 * 3" 为例列出每一步展开的过程。</p>
<pre><code>0.               Expr
1. 应用规则1      Expr + Term
2. 应用规则4      Expr + Term * Factor
3. 应用规则7      Expr + Term * Number
4. 应用规则6      Expr + Factor * Number
5. 应用规则7      Expr + Number * Number
6. 应用规则3      Term + Number * Number
7. 应用规则6      Factor + Number * Number
8. 应用规则7      Number + Number * Number
</code></pre>
<p>不同运算符的优先级能在上述语法规则中体现吗？可以的，箭头左边的表达式，从上往下优先级递增。</p>
<p>上述语法真的能 work 吗？这里其实有一个在 RD 中非常出名的问题——Left Recursion</p>
<p>回到我们展开“1 + 2 _ 3”这里例子，在第 4 行的时候我们应用规则 6，将 Term 展开成 Factor，得到了 Expr + Factor _ Number。Term 展开成了 Factor，为什么不是 Term _ Factor，不是 Term / Factor 呢？这里我们站在上帝视角，知道应该走 Term → Factor → Number 路径才是正确的，但是根据我们的语法规则定义，由“｜”连接起来的都是平等的。好，现在放弃上帝视角，Term 展开成 Term _ Factor，Term _ Factor 中的 Term 又可以展开成 Term _ Factor，现在变成了 Term _ Term _ Factor，以此类推，将无线递归下去。stack overflow！！！</p>
<p>怎么解决这个问题呢？其实很简单，表达式展开的时候不要把自身写在最左边</p>
<pre><code>Expr -> Term + Expr
      | Term - Expr
      | Term
Term -> Factor * Term
      | Factor / Term
      | Factor
Factor -> Number
</code></pre>
<p>写成这样的语法规则能达到我们最开始设计时的那三点要求吗？oh，我们好像还没讨论运算符优先级相同时的情况。</p>
<p>考虑“1 + 2 + 3”会被 parse 成什么？答案是“(1 + (2 + 3))”，竟然是先算右边的，你可能会觉得先算右边好像也没啥大不了嘛，结果都一样，为啥要强调得先算左边呢？那试试“1 - 2 - 3”呢？为什么会先算右边呢？你可以尝试根据语法规则一步步展开推一下。感兴趣的话，这儿有一份用 python 实现的 parser，语法比我们这个略微复杂一点，（代码不是我写的，我甚至都没有看过，我只看了大佬的博客）。</p>
<p>刚刚讨论的其实是 parser 中一个非常重要的问题，叫 Asscociativity，像“+”，“-”，“*”，“/”都是 left-associative，“=”是一个典型的 right-associative，“a = b = c”应该被 parse 为 “a = (b = c)”。</p>
<pre><code>Expr -> Term {+ Term}
      | Term {- Term}
      | Term
Term -> Factor {* Factor}
      | Factor {/ Term}
      | Factor
Factor -> Number
</code></pre>
<p>“{}”表示括号内可以重复一次或多次。（忘了“{}”这个叫中括号还是大括号了。。。）</p>
<p>这次它真的可以解决 left-associative 的问题，不信你可以推一下（狗头）。</p>
<h2>优缺点</h2>
<blockquote>
<p>Recursive descent parsers are fast, robust, and can support sophisticated error handling. In fact, GCC, V8 (the JavaScript VM in Chrome), Roslyn (the C# compiler written in C#) and many other heavyweight production language implementations use recursive descent.</p>
</blockquote>
<p>这是《Crafting Interpreters》中说的，又快有稳定，GCC 都在用。但是下面两篇文章都指出 RD 有性能问题，每个优先级在语法规则中都会有一个单独的 level，直白点，代码中每个优先级会对应一个函数，优先级层数越多，对应的函数也就越多。即使输入只有一个 token “1”，也需要先后调用 expr，term，factor 函数。</p>
<p><a href="https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm">https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a></p>
<p><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/">https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></p>
<p>这一块还没有怎么调研，先挖个坑吧。</p>
<h2>参考</h2>
<p>贴一下我觉得有用的文章，有用程度和先后顺序有关</p>
<p><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/">https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></p>
<p><a href="https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm">https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a></p>
<p>《Engineering A Compiler (second edition)》3.3 left recursion</p>
<p><a href="http://craftinginterpreters.com/parsing-expressions.html#ambiguity-and-the-parsing-game">http://craftinginterpreters.com/parsing-expressions.html#ambiguity-and-the-parsing-game</a></p>
<h2>Implementing it in Rust</h2>
<p>最后用 rust 实现了最终版的 RD，手动 lexer，哈哈哈</p>
<pre><code class="hljs language-Rust"><span class="hljs-comment">/*
Expr -> Term {+ Term}
      | Term {- Term}
      | Term
Term -> Factor {* Factor}
      | Factor {/ Factor}
      | Factor
Factor -> Number

 */</span>
<span class="hljs-keyword">use</span> std::fmt;
<span class="hljs-keyword">use</span> std::iter::Peekable;

<span class="hljs-meta">#[derive(Debug, Clone)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Token</span> {
    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">u32</span>),
    Plus,
    Minus,
    Star,
    Slash,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Token</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&#x26;<span class="hljs-keyword">self</span>, f: &#x26;<span class="hljs-keyword">mut</span> fmt::Formatter&#x3C;<span class="hljs-symbol">'_</span>>) <span class="hljs-punctuation">-></span> fmt::<span class="hljs-type">Result</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            Token::<span class="hljs-title function_ invoke__">Number</span>(n) => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{}"</span>, n),
            Token::Plus => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"+"</span>),
            Token::Minus => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"-"</span>),
            Token::Star => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"*"</span>),
            Token::Slash => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"/"</span>),
        }
    }
}

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Expr</span> {
    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">u32</span>),
    <span class="hljs-title function_ invoke__">Binary</span>(<span class="hljs-type">Box</span>&#x3C;Expr>, Token, <span class="hljs-type">Box</span>&#x3C;Expr>),
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Expr</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&#x26;<span class="hljs-keyword">self</span>, f: &#x26;<span class="hljs-keyword">mut</span> fmt::Formatter&#x3C;<span class="hljs-symbol">'_</span>>) <span class="hljs-punctuation">-></span> fmt::<span class="hljs-type">Result</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            Expr::<span class="hljs-title function_ invoke__">Number</span>(n) => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{}"</span>, n),
            Expr::<span class="hljs-title function_ invoke__">Binary</span>(lhs, token, rhs) => {
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"({} "</span>, lhs)?;
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{} "</span>, token)?;
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{})"</span>, rhs)
            }
        }
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">expr</span>&#x3C;I: <span class="hljs-built_in">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class="hljs-keyword">mut</span> Peekable&#x3C;I>) <span class="hljs-punctuation">-></span> Expr {
    <span class="hljs-title function_ invoke__">term</span>(token_iter)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">term</span>&#x3C;I: <span class="hljs-built_in">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class="hljs-keyword">mut</span> Peekable&#x3C;I>) <span class="hljs-punctuation">-></span> Expr {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-title function_ invoke__">factor</span>(token_iter);
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(token) = token_iter.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">cloned</span>() {
        <span class="hljs-keyword">match</span> token {
            Token::Plus | Token::Minus => {
                token_iter.<span class="hljs-title function_ invoke__">next</span>();
                <span class="hljs-keyword">let</span> <span class="hljs-variable">rhs</span> = <span class="hljs-title function_ invoke__">factor</span>(token_iter);
                lhs = Expr::<span class="hljs-title function_ invoke__">Binary</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(lhs), token, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(rhs));
            }
            _ => <span class="hljs-keyword">break</span>,
        }
    }
    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">factor</span>&#x3C;I: <span class="hljs-built_in">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class="hljs-keyword">mut</span> Peekable&#x3C;I>) <span class="hljs-punctuation">-></span> Expr {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-title function_ invoke__">primary</span>(token_iter);
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(token) = token_iter.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">cloned</span>() {
        <span class="hljs-keyword">match</span> token {
            Token::Slash | Token::Star => {
                token_iter.<span class="hljs-title function_ invoke__">next</span>();
                <span class="hljs-keyword">let</span> <span class="hljs-variable">rhs</span> = <span class="hljs-title function_ invoke__">primary</span>(token_iter);
                lhs = Expr::<span class="hljs-title function_ invoke__">Binary</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(lhs), token, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(rhs));
            }
            _ => <span class="hljs-keyword">break</span>,
        }
    }
    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">primary</span>&#x3C;I: <span class="hljs-built_in">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class="hljs-keyword">mut</span> Peekable&#x3C;I>) <span class="hljs-punctuation">-></span> Expr {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(Token::<span class="hljs-title function_ invoke__">Number</span>(n)) = token_iter.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">cloned</span>() {
        token_iter.<span class="hljs-title function_ invoke__">next</span>();
        <span class="hljs-keyword">return</span> Expr::<span class="hljs-title function_ invoke__">Number</span>(n);
    }
    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"No more tokens left"</span>)
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">tokens</span> = <span class="hljs-built_in">vec!</span>[
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1</span>),
        Token::Plus,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">2</span>),
        Token::Slash,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">3</span>),
    ];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">expr</span>(&#x26;<span class="hljs-keyword">mut</span> tokens.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">peekable</span>());
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">"(1 + (2 / 3))"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-variable">tokens</span> = <span class="hljs-built_in">vec!</span>[
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1</span>),
        Token::Minus,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">2</span>),
        Token::Plus,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">3</span>),
    ];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">expr</span>(&#x26;<span class="hljs-keyword">mut</span> tokens.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">peekable</span>());
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">"((1 - 2) + 3)"</span>);
}
</code></pre></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"crafting_interpreters_2","contentHtml":"\u003cp\u003e\u003ca href=\"http://www.craftinginterpreters.com/\"\u003e《Crafting Interpreters》\u003c/a\u003e中 jlox（Part I 中用 java 实现的 Lox 语言）用了 recursive descent parsing 去实现 parser。为了偷懒，下面用 RD 代指 recursive descent parsing 这个方法。\u003c/p\u003e\n\u003ch2\u003e设计简易计算器\u003c/h2\u003e\n\u003cp\u003e假如我们现在要实现一个支持加减乘除的计算器，那 parser 应该怎么设计？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e并不是所有的输入都是支持的，比如输入“1 +/ 2”\u003c/li\u003e\n\u003cli\u003e不同运算符优先级不一样，考虑“1 + 2 * 3”，应该先算乘法，再算加法\u003c/li\u003e\n\u003cli\u003e当运算符优先级一样时，应该优先算靠左边的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上面三条都是在定义或者限制计算器的语法规则，我们将语法规则用一套符号语言去表示。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExpr -\u003e Expr + Term     (1)\n      | Expr - Term     (2)\n      | Term            (3)\nTerm -\u003e Term * Factor   (4)\n      | Term / Factor   (5)\n      | Factor          (6)\nFactor -\u003e Number        (7)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每一行表示一条语法规则，为了方便描述，给每条规则都标了号，这里一共有 7 条规则。上面的这套符号应该怎么理解呢？箭头左边的表达式可以转换成右边的表达式，“｜”表示逻辑或，比如说 Expr 可以展开成 Expr + Term， Expr - Term 和 Term 中的任何一个， 以\"1 + 2 * 3\" 为例列出每一步展开的过程。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0.               Expr\n1. 应用规则1      Expr + Term\n2. 应用规则4      Expr + Term * Factor\n3. 应用规则7      Expr + Term * Number\n4. 应用规则6      Expr + Factor * Number\n5. 应用规则7      Expr + Number * Number\n6. 应用规则3      Term + Number * Number\n7. 应用规则6      Factor + Number * Number\n8. 应用规则7      Number + Number * Number\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e不同运算符的优先级能在上述语法规则中体现吗？可以的，箭头左边的表达式，从上往下优先级递增。\u003c/p\u003e\n\u003cp\u003e上述语法真的能 work 吗？这里其实有一个在 RD 中非常出名的问题——Left Recursion\u003c/p\u003e\n\u003cp\u003e回到我们展开“1 + 2 _ 3”这里例子，在第 4 行的时候我们应用规则 6，将 Term 展开成 Factor，得到了 Expr + Factor _ Number。Term 展开成了 Factor，为什么不是 Term _ Factor，不是 Term / Factor 呢？这里我们站在上帝视角，知道应该走 Term → Factor → Number 路径才是正确的，但是根据我们的语法规则定义，由“｜”连接起来的都是平等的。好，现在放弃上帝视角，Term 展开成 Term _ Factor，Term _ Factor 中的 Term 又可以展开成 Term _ Factor，现在变成了 Term _ Term _ Factor，以此类推，将无线递归下去。stack overflow！！！\u003c/p\u003e\n\u003cp\u003e怎么解决这个问题呢？其实很简单，表达式展开的时候不要把自身写在最左边\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExpr -\u003e Term + Expr\n      | Term - Expr\n      | Term\nTerm -\u003e Factor * Term\n      | Factor / Term\n      | Factor\nFactor -\u003e Number\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e写成这样的语法规则能达到我们最开始设计时的那三点要求吗？oh，我们好像还没讨论运算符优先级相同时的情况。\u003c/p\u003e\n\u003cp\u003e考虑“1 + 2 + 3”会被 parse 成什么？答案是“(1 + (2 + 3))”，竟然是先算右边的，你可能会觉得先算右边好像也没啥大不了嘛，结果都一样，为啥要强调得先算左边呢？那试试“1 - 2 - 3”呢？为什么会先算右边呢？你可以尝试根据语法规则一步步展开推一下。感兴趣的话，这儿有一份用 python 实现的 parser，语法比我们这个略微复杂一点，（代码不是我写的，我甚至都没有看过，我只看了大佬的博客）。\u003c/p\u003e\n\u003cp\u003e刚刚讨论的其实是 parser 中一个非常重要的问题，叫 Asscociativity，像“+”，“-”，“*”，“/”都是 left-associative，“=”是一个典型的 right-associative，“a = b = c”应该被 parse 为 “a = (b = c)”。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExpr -\u003e Term {+ Term}\n      | Term {- Term}\n      | Term\nTerm -\u003e Factor {* Factor}\n      | Factor {/ Term}\n      | Factor\nFactor -\u003e Number\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e“{}”表示括号内可以重复一次或多次。（忘了“{}”这个叫中括号还是大括号了。。。）\u003c/p\u003e\n\u003cp\u003e这次它真的可以解决 left-associative 的问题，不信你可以推一下（狗头）。\u003c/p\u003e\n\u003ch2\u003e优缺点\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRecursive descent parsers are fast, robust, and can support sophisticated error handling. In fact, GCC, V8 (the JavaScript VM in Chrome), Roslyn (the C# compiler written in C#) and many other heavyweight production language implementations use recursive descent.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这是《Crafting Interpreters》中说的，又快有稳定，GCC 都在用。但是下面两篇文章都指出 RD 有性能问题，每个优先级在语法规则中都会有一个单独的 level，直白点，代码中每个优先级会对应一个函数，优先级层数越多，对应的函数也就越多。即使输入只有一个 token “1”，也需要先后调用 expr，term，factor 函数。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm\"\u003ehttps://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/\"\u003ehttps://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这一块还没有怎么调研，先挖个坑吧。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e贴一下我觉得有用的文章，有用程度和先后顺序有关\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/\"\u003ehttps://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm\"\u003ehttps://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e《Engineering A Compiler (second edition)》3.3 left recursion\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://craftinginterpreters.com/parsing-expressions.html#ambiguity-and-the-parsing-game\"\u003ehttp://craftinginterpreters.com/parsing-expressions.html#ambiguity-and-the-parsing-game\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eImplementing it in Rust\u003c/h2\u003e\n\u003cp\u003e最后用 rust 实现了最终版的 RD，手动 lexer，哈哈哈\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e/*\nExpr -\u003e Term {+ Term}\n      | Term {- Term}\n      | Term\nTerm -\u003e Factor {* Factor}\n      | Factor {/ Factor}\n      | Factor\nFactor -\u003e Number\n\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::fmt;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::iter::Peekable;\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug, Clone)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eToken\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e),\n    Plus,\n    Minus,\n    Star,\n    Slash,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003efmt\u003c/span\u003e::Display \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eToken\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efmt\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, f: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e fmt::Formatter\u0026#x3C;\u003cspan class=\"hljs-symbol\"\u003e'_\u003c/span\u003e\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e fmt::\u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e {\n            Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(n) =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, n),\n            Token::Plus =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"+\"\u003c/span\u003e),\n            Token::Minus =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"-\"\u003c/span\u003e),\n            Token::Star =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e),\n            Token::Slash =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e),\n        }\n    }\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExpr\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e\u0026#x3C;Expr\u003e, Token, \u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e\u0026#x3C;Expr\u003e),\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003efmt\u003c/span\u003e::Display \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExpr\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efmt\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, f: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e fmt::Formatter\u0026#x3C;\u003cspan class=\"hljs-symbol\"\u003e'_\u003c/span\u003e\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e fmt::\u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e {\n            Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(n) =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, n),\n            Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(lhs, token, rhs) =\u003e {\n                \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"({} \"\u003c/span\u003e, lhs)?;\n                \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{} \"\u003c/span\u003e, token)?;\n                \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{})\"\u003c/span\u003e, rhs)\n            }\n        }\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexpr\u003c/span\u003e\u0026#x3C;I: \u003cspan class=\"hljs-built_in\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Token\u003e\u003e(token_iter: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e Peekable\u0026#x3C;I\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Expr {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eterm\u003c/span\u003e(token_iter)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eterm\u003c/span\u003e\u0026#x3C;I: \u003cspan class=\"hljs-built_in\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Token\u003e\u003e(token_iter: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e Peekable\u0026#x3C;I\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Expr {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003elhs\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efactor\u003c/span\u003e(token_iter);\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(token) = token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003epeek\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003ecloned\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e token {\n            Token::Plus | Token::Minus =\u003e {\n                token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e();\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erhs\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efactor\u003c/span\u003e(token_iter);\n                lhs = Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(lhs), token, \u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(rhs));\n            }\n            _ =\u003e \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e,\n        }\n    }\n    lhs\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efactor\u003c/span\u003e\u0026#x3C;I: \u003cspan class=\"hljs-built_in\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Token\u003e\u003e(token_iter: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e Peekable\u0026#x3C;I\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Expr {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003elhs\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eprimary\u003c/span\u003e(token_iter);\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(token) = token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003epeek\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003ecloned\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e token {\n            Token::Slash | Token::Star =\u003e {\n                token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e();\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erhs\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eprimary\u003c/span\u003e(token_iter);\n                lhs = Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(lhs), token, \u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(rhs));\n            }\n            _ =\u003e \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e,\n        }\n    }\n    lhs\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprimary\u003c/span\u003e\u0026#x3C;I: \u003cspan class=\"hljs-built_in\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Token\u003e\u003e(token_iter: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e Peekable\u0026#x3C;I\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Expr {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(n)) = token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003epeek\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003ecloned\u003c/span\u003e() {\n        token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(n);\n    }\n    \u003cspan class=\"hljs-built_in\"\u003epanic!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"No more tokens left\"\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[test]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etests\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etokens\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n        Token::Plus,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n        Token::Slash,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e),\n    ];\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eexpr\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e tokens.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003epeekable\u003c/span\u003e());\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(s.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(), \u003cspan class=\"hljs-string\"\u003e\"(1 + (2 / 3))\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etokens\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n        Token::Minus,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n        Token::Plus,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e),\n    ];\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eexpr\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e tokens.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003epeekable\u003c/span\u003e());\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(s.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(), \u003cspan class=\"hljs-string\"\u003e\"((1 - 2) + 3)\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e","title":"《Crafting Interpreters》阅读笔记（二）","date":"2021-10-17"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"crafting_interpreters_2"},"buildId":"gQcfR_oSI5UIowtnKE0vz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>