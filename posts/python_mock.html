<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>深入理解 Python Mock 库：Mock，patch 和 patch.object 的实现原理</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/ab65974685f462b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab65974685f462b8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/LgI_2aaq_4GSrY0V2y1Bt/_buildManifest.js" defer=""></script><script src="/_next/static/LgI_2aaq_4GSrY0V2y1Bt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">深入理解 Python Mock 库：Mock，patch 和 patch.object 的实现原理</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2023-07-08">July 8, 2023</time></div><div><p>Python 中 <code>unittest.mock</code> 是我经常用到的一个库，它提供了非常方便的 mock 功能，可以帮助我们写出更好的单元测试。本文不是介绍 <code>unittest.mock</code> 的使用，而是探讨它的实现原理，从零开始实现 <code>unittest.mock</code> 中的 <code>Mock</code>，<code>patch</code> 和 <code>patch.object</code>，帮助我们更好地理解它们的工作原理。</p>
<h2>如何 mock 一个函数</h2>
<p>假如有一个函数 <code>random_boolean</code>，实现如下：</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">def</span> <span class="hljs-title function_">random_boolean</span>(<span class="hljs-params">threshold=<span class="hljs-number">0.5</span></span>):
    <span class="hljs-keyword">return</span> random.random() &#x3C; threshold
</code></pre>
<p>我现在想给这个函数写一个单元测试，测试它的返回值是否符合预期，应该怎么做呢？</p>
<p>这时候可以 mock <code>random.random()</code>，让它总是返回小于 0.5 的值，测试 <code>random_boolean</code> 的返回值是否为 <code>True</code>。</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch
<span class="hljs-keyword">from</span> my_module <span class="hljs-keyword">import</span> random_boolean

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_random_boolean</span>():
    <span class="hljs-keyword">with</span> patch(<span class="hljs-string">'random.random'</span>, new=<span class="hljs-keyword">lambda</span>: random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>)):
        <span class="hljs-keyword">assert</span> random_boolean() == <span class="hljs-literal">True</span>
</code></pre>
<p>接下来看看如何实现 <code>patch</code>，让它完成上述的功能呢？</p>
<h3>实现 patch</h3>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> importlib

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Patch</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, target, new</span>):
        self.target = target
        self.new = new
        self.original = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Split the target into module and attribute</span>
        parts = self.target.split(<span class="hljs-string">'.'</span>)
        module_name = <span class="hljs-string">'.'</span>.join(parts[:-<span class="hljs-number">1</span>])
        attr_name = parts[-<span class="hljs-number">1</span>]
        
        <span class="hljs-comment"># Import the module and get the original attribute</span>
        module = importlib.import_module(module_name)
        self.original = <span class="hljs-built_in">getattr</span>(module, attr_name)
        
        <span class="hljs-comment"># Replace the original attribute with the new one</span>
        <span class="hljs-built_in">setattr</span>(module, attr_name, self.new)
        <span class="hljs-keyword">return</span> self.new

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):
        <span class="hljs-comment"># Restore the original attribute when exiting the with block</span>
        parts = self.target.split(<span class="hljs-string">'.'</span>)
        module_name = <span class="hljs-string">'.'</span>.join(parts[:-<span class="hljs-number">1</span>])
        attr_name = parts[-<span class="hljs-number">1</span>]
        module = importlib.import_module(module_name)
        <span class="hljs-built_in">setattr</span>(module, attr_name, self.original)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">target, new</span>):
    <span class="hljs-keyword">return</span> Patch(target, new)
</code></pre>
<p>实现的核心思路是，通过 <code>importlib.import_module</code> 导入需要 patch 的模块（<code>random</code>），然后通过 <code>setattr</code> 将模块中的需要 patch 的属性（random 模块中的 <code>random()</code> 函数）替换为新的值（<code>lambda: random.uniform(0, 0.5)</code>）。替换只在 <code>with</code> 语句块中生效，<code>with</code> 语句块结束后，再将原来的值赋回去。</p>
<h2>如何 mock 一个类方法</h2>
<p>假设现在有这样一个类：</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductionClass</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.something(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">self, a, b, c</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>我想 mock <code>something</code> 方法，可以用 <code>unittest.mock.patch.object</code> 来实现：</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> unittest.mock <span class="hljs-keyword">import</span> patch
<span class="hljs-keyword">from</span> my_module <span class="hljs-keyword">import</span> ProductionClass

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_method</span>():
    <span class="hljs-keyword">with</span> patch.<span class="hljs-built_in">object</span>(ProductionClass, <span class="hljs-string">'something'</span>, new=<span class="hljs-keyword">lambda</span> self, a, b, c: <span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> mock_method:
        <span class="hljs-keyword">assert</span> ProductionClass().method() == <span class="hljs-number">3</span>
</code></pre>
<h3>实现 patch.object</h3>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PatchObject</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, target, attr, new</span>):
        self.target = target
        self.attr = attr
        self.new = new
        self.original = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Get the original attribute</span>
        self.original = <span class="hljs-built_in">getattr</span>(self.target, self.attr)
        
        <span class="hljs-comment"># Replace the original attribute with the new one</span>
        <span class="hljs-built_in">setattr</span>(self.target, self.attr, self.new)
        <span class="hljs-keyword">return</span> self.new

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):
        <span class="hljs-comment"># Restore the original attribute when exiting the with block</span>
        <span class="hljs-built_in">setattr</span>(self.target, self.attr, self.original)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">patch_object</span>(<span class="hljs-params">target, attr, new</span>):
    <span class="hljs-keyword">return</span> PatchObject(target, attr, new)
</code></pre>
<p>实现的核心思路是，通过 <code>getattr</code> 获取需要 patch 的属性（<code>something</code> 方法），然后通过 <code>setattr</code> 将属性替换为新的值（<code>lambda self, a, b, c: 3</code>）。替换只在 <code>with</code> 语句块中生效，<code>with</code> 语句块结束后，再将原来的值赋回去。</p>
<h2>实现 Mock</h2>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mock</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, return_value=<span class="hljs-literal">None</span></span>):
        self._methods = {}
        self.return_value = return_value
        self.call_count = <span class="hljs-number">0</span>
        self.call_args = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._methods:
            self._methods[name] = Mock()
        <span class="hljs-keyword">return</span> self._methods[name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, Mock):
            self._methods[name] = value
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">super</span>().__setattr__(name, value)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        self.call_count += <span class="hljs-number">1</span>
        self.call_args = (args, kwargs)
        <span class="hljs-keyword">if</span> self.return_value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> Mock()
        <span class="hljs-keyword">return</span> self.return_value
</code></pre>
<p>Mock 类的主要工作原理是，当我们试图访问它的一个属性时，如果这个属性不存在，那么它就会创建一个新的 Mock 实例并返回。这样，我们就可以无限制地访问它的属性，每个属性都是一个新的 Mock 实例。当我们调用 Mock 实例时，它会记录调用的次数和参数，并返回一个预设的值或者一个新的 Mock 实例。</p>
<hr>
<p>通过上述的讨论，我们深入地了解了 Python 的 mock 库的实现原理。我们了解了如何通过修改模块的属性来模拟函数或者方法的行为，以及如何通过 Mock 类来模拟对象的行为。然而，实际的 mock 库的实现要比我们讨论的更复杂，它还包括了很多其他的特性，例如 side_effect、call_args_list 等。如果你对这个主题感兴趣，我鼓励你去阅读 Python 官方文档或者 mock 库的源代码，以获取更深入的理解。</p></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"python_mock","contentHtml":"\u003cp\u003ePython 中 \u003ccode\u003eunittest.mock\u003c/code\u003e 是我经常用到的一个库，它提供了非常方便的 mock 功能，可以帮助我们写出更好的单元测试。本文不是介绍 \u003ccode\u003eunittest.mock\u003c/code\u003e 的使用，而是探讨它的实现原理，从零开始实现 \u003ccode\u003eunittest.mock\u003c/code\u003e 中的 \u003ccode\u003eMock\u003c/code\u003e，\u003ccode\u003epatch\u003c/code\u003e 和 \u003ccode\u003epatch.object\u003c/code\u003e，帮助我们更好地理解它们的工作原理。\u003c/p\u003e\n\u003ch2\u003e如何 mock 一个函数\u003c/h2\u003e\n\u003cp\u003e假如有一个函数 \u003ccode\u003erandom_boolean\u003c/code\u003e，实现如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e random\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erandom_boolean\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ethreshold=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e random.random() \u0026#x3C; threshold\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我现在想给这个函数写一个单元测试，测试它的返回值是否符合预期，应该怎么做呢？\u003c/p\u003e\n\u003cp\u003e这时候可以 mock \u003ccode\u003erandom.random()\u003c/code\u003e，让它总是返回小于 0.5 的值，测试 \u003ccode\u003erandom_boolean\u003c/code\u003e 的返回值是否为 \u003ccode\u003eTrue\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e unittest.mock \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e patch\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e my_module \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e random_boolean\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etest_random_boolean\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e patch(\u003cspan class=\"hljs-string\"\u003e'random.random'\u003c/span\u003e, new=\u003cspan class=\"hljs-keyword\"\u003elambda\u003c/span\u003e: random.uniform(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e)):\n        \u003cspan class=\"hljs-keyword\"\u003eassert\u003c/span\u003e random_boolean() == \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来看看如何实现 \u003ccode\u003epatch\u003c/code\u003e，让它完成上述的功能呢？\u003c/p\u003e\n\u003ch3\u003e实现 patch\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e importlib\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePatch\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, target, new\u003c/span\u003e):\n        self.target = target\n        self.new = new\n        self.original = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__enter__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-comment\"\u003e# Split the target into module and attribute\u003c/span\u003e\n        parts = self.target.split(\u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e)\n        module_name = \u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e.join(parts[:-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n        attr_name = parts[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n        \n        \u003cspan class=\"hljs-comment\"\u003e# Import the module and get the original attribute\u003c/span\u003e\n        module = importlib.import_module(module_name)\n        self.original = \u003cspan class=\"hljs-built_in\"\u003egetattr\u003c/span\u003e(module, attr_name)\n        \n        \u003cspan class=\"hljs-comment\"\u003e# Replace the original attribute with the new one\u003c/span\u003e\n        \u003cspan class=\"hljs-built_in\"\u003esetattr\u003c/span\u003e(module, attr_name, self.new)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.new\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__exit__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, exc_type, exc_val, exc_tb\u003c/span\u003e):\n        \u003cspan class=\"hljs-comment\"\u003e# Restore the original attribute when exiting the with block\u003c/span\u003e\n        parts = self.target.split(\u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e)\n        module_name = \u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e.join(parts[:-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n        attr_name = parts[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n        module = importlib.import_module(module_name)\n        \u003cspan class=\"hljs-built_in\"\u003esetattr\u003c/span\u003e(module, attr_name, self.original)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epatch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget, new\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Patch(target, new)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现的核心思路是，通过 \u003ccode\u003eimportlib.import_module\u003c/code\u003e 导入需要 patch 的模块（\u003ccode\u003erandom\u003c/code\u003e），然后通过 \u003ccode\u003esetattr\u003c/code\u003e 将模块中的需要 patch 的属性（random 模块中的 \u003ccode\u003erandom()\u003c/code\u003e 函数）替换为新的值（\u003ccode\u003elambda: random.uniform(0, 0.5)\u003c/code\u003e）。替换只在 \u003ccode\u003ewith\u003c/code\u003e 语句块中生效，\u003ccode\u003ewith\u003c/code\u003e 语句块结束后，再将原来的值赋回去。\u003c/p\u003e\n\u003ch2\u003e如何 mock 一个类方法\u003c/h2\u003e\n\u003cp\u003e假设现在有这样一个类：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductionClass\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.something(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, a, b, c\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003epass\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我想 mock \u003ccode\u003esomething\u003c/code\u003e 方法，可以用 \u003ccode\u003eunittest.mock.patch.object\u003c/code\u003e 来实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e unittest.mock \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e patch\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e my_module \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ProductionClass\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etest_method\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e patch.\u003cspan class=\"hljs-built_in\"\u003eobject\u003c/span\u003e(ProductionClass, \u003cspan class=\"hljs-string\"\u003e'something'\u003c/span\u003e, new=\u003cspan class=\"hljs-keyword\"\u003elambda\u003c/span\u003e self, a, b, c: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e mock_method:\n        \u003cspan class=\"hljs-keyword\"\u003eassert\u003c/span\u003e ProductionClass().method() == \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e实现 patch.object\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePatchObject\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, target, attr, new\u003c/span\u003e):\n        self.target = target\n        self.attr = attr\n        self.new = new\n        self.original = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__enter__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-comment\"\u003e# Get the original attribute\u003c/span\u003e\n        self.original = \u003cspan class=\"hljs-built_in\"\u003egetattr\u003c/span\u003e(self.target, self.attr)\n        \n        \u003cspan class=\"hljs-comment\"\u003e# Replace the original attribute with the new one\u003c/span\u003e\n        \u003cspan class=\"hljs-built_in\"\u003esetattr\u003c/span\u003e(self.target, self.attr, self.new)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.new\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__exit__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, exc_type, exc_val, exc_tb\u003c/span\u003e):\n        \u003cspan class=\"hljs-comment\"\u003e# Restore the original attribute when exiting the with block\u003c/span\u003e\n        \u003cspan class=\"hljs-built_in\"\u003esetattr\u003c/span\u003e(self.target, self.attr, self.original)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epatch_object\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget, attr, new\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e PatchObject(target, attr, new)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现的核心思路是，通过 \u003ccode\u003egetattr\u003c/code\u003e 获取需要 patch 的属性（\u003ccode\u003esomething\u003c/code\u003e 方法），然后通过 \u003ccode\u003esetattr\u003c/code\u003e 将属性替换为新的值（\u003ccode\u003elambda self, a, b, c: 3\u003c/code\u003e）。替换只在 \u003ccode\u003ewith\u003c/code\u003e 语句块中生效，\u003ccode\u003ewith\u003c/code\u003e 语句块结束后，再将原来的值赋回去。\u003c/p\u003e\n\u003ch2\u003e实现 Mock\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMock\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, return_value=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e):\n        self._methods = {}\n        self.return_value = return_value\n        self.call_count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        self.call_args = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__getattr__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e name \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self._methods:\n            self._methods[name] = Mock()\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self._methods[name]\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__setattr__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name, value\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eisinstance\u003c/span\u003e(value, Mock):\n            self._methods[name] = value\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e().__setattr__(name, value)\n    \n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__call__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, *args, **kwargs\u003c/span\u003e):\n        self.call_count += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        self.call_args = (args, kwargs)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.return_value \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Mock()\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.return_value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMock 类的主要工作原理是，当我们试图访问它的一个属性时，如果这个属性不存在，那么它就会创建一个新的 Mock 实例并返回。这样，我们就可以无限制地访问它的属性，每个属性都是一个新的 Mock 实例。当我们调用 Mock 实例时，它会记录调用的次数和参数，并返回一个预设的值或者一个新的 Mock 实例。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e通过上述的讨论，我们深入地了解了 Python 的 mock 库的实现原理。我们了解了如何通过修改模块的属性来模拟函数或者方法的行为，以及如何通过 Mock 类来模拟对象的行为。然而，实际的 mock 库的实现要比我们讨论的更复杂，它还包括了很多其他的特性，例如 side_effect、call_args_list 等。如果你对这个主题感兴趣，我鼓励你去阅读 Python 官方文档或者 mock 库的源代码，以获取更深入的理解。\u003c/p\u003e","title":"深入理解 Python Mock 库：Mock，patch 和 patch.object 的实现原理","date":"2023-07-08"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"python_mock"},"buildId":"LgI_2aaq_4GSrY0V2y1Bt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>