<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>如何看待 rust 体系中 rowan 的红绿树</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/352a7f6477311b3a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/352a7f6477311b3a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/EEU_erGoU_JDwBtAMKr2I/_buildManifest.js" defer=""></script><script src="/_next/static/EEU_erGoU_JDwBtAMKr2I/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">如何看待 rust 体系中 rowan 的红绿树</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2022-04-01">April 1, 2022</time></div><div><p>本文源自我在知乎的一个回答，原文地址：<a href="https://www.zhihu.com/question/525030607/answer/2418851335">https://www.zhihu.com/question/525030607/answer/2418851335</a></p>
<p>原问题为：</p>
<blockquote>
<p>仓库：<a href="https://github.com/rust-analyzer/rowan">https://github.com/rust-analyzer/rowan</a><br>
参考文献：<a href="https://blog.walterlv.com/post/the-red-green-tree-of-roslyn.html">理解 Roslyn 中的红绿树（Red-Green Trees</a><br>
这种设计似乎可以应用在lsp中作为提高语言增量解析和构建的效率。<br>
不过尚未深刻理解其算法的精妙~</p>
</blockquote>
<h2>回答</h2>
<p>题主给了篇参考文章</p>
<blockquote>
<p>Roslyn 一开始就将漂亮的 API 作为目标的一部分，同时还要非常高的性能；所以 Roslyn 的开发团队需要找到一种特殊的数据结构来描述语言（如 C#）的语法。这种数据结构要满足这些期望的要求：</p>
<ol>
<li>不可变（Immutable）</li>
<li>树的形式</li>
<li>可以容易地访问父节点和子节点</li>
<li>可以非常容易地将任何一个节点对应到源代码文件的一段文本区间</li>
<li>可重用（Persistent）</li>
</ol>
</blockquote>
<p>从第 4 点开始说，这是一个很常见的需求，想想我们的编译器报错信息，能够指出错误出现在源文件的哪一行哪一列。我们可能设计出下面这种数据结构作为 syntax tree</p>
<pre><code class="hljs language-Rust"><span class="hljs-meta">#[derive(PartialEq, Eq, Clone, Copy)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SyntaxKind</span>(<span class="hljs-type">u16</span>);

<span class="hljs-meta">#[derive(PartialEq, Eq, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
    kind: SyntaxKind,
    text_len: <span class="hljs-type">usize</span>,
    children: <span class="hljs-type">Vec</span>&#x3C;Arc&#x3C;Either&#x3C;Node, Token>>>,
    offset: <span class="hljs-type">usize</span>
}

<span class="hljs-meta">#[derive(PartialEq, Eq, Clone)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Token</span> {
    kind: SyntaxKind,
    text: <span class="hljs-type">String</span>,
    offset: <span class="hljs-type">usize</span>
}

<span class="hljs-comment">// https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md</span>
</code></pre>
<p>对于 <code>1 + 2</code> ，我们会得到如下的 syntax tree</p>
<pre><code>               +-----------------+
               |  Node           |
               |  kind: BinExpr  |
      +--------+  text_len: 5    +-------+
      |        |  offset: 0      |       |
      |        +-------+---------+       |
      |                |                 |
      |                |                 |
      |                |                 |
      |                |                 |
      |                |                 |
      |                |                 |
      v                v                 v
+----------+    +------------+    +-----------+
|Token     |    | Token      |    | Token     |
|kind: int |    | kind: plus |    | kind: int |
|text: 1   |    | text: +    |    | text: 2   |
|offset: 0 |    | offset: 2  |    | offset: 4 |
+----------+    +------------+    +-----------+
</code></pre>
<p>如果我们把 source code 简单改一下，多加一个 whitespace，即 <code>1  + 2</code> ，我们的 syntax tree 会发生变化吗？当然，从 + 开始所有节点的 offset 都要发生变化。真实场景中 source code 会复杂得多，加一个 whitespace，整个 syntax tree 就作废了。太浪费了，加 whitespace，加 comments 其实并不影响我们的 syntax，有没有方法使得语法无关的修改不改变 syntax tree 呢？</p>
<p>很容易能想到，我们的 node 不包含 offset 不就可以了吗？问题是如果不包含 offset，“任何一个节点对应到源代码文件的一段文本区间” 这条就不满足了。</p>
<p>我们可以把 whitespace 也放到 syntax tree 中。</p>
<pre><code>                               +---------------+
                               | Node          |
      +---------------+--------+ kind: BinExpr +---------+----------------+
      |               |        | text_len: 5   |         |                |
      |               |        +-------+-------+         |                |
      |               |                |                 |                |
      |               |                |                 |                |
      |               |                |                 |                |
      |               |                |                 |                |
      |               |                |                 |                |
      |               |                |                 |                |
      |               |                |                 |                |
      |               |                |                 |                |
      v               v                v                 v                v
+-----------+   +-----------+    +------------+    +-----------+    +-----------+
| Token     |   | Token     |    | Token      |    | Token     |    | Token     |
| kind: int |   | kind: wp  |    | kind: plus |    | kind: wp  |    | kind: int |
| text: 1   |   | text: ' ' |    | text: +    |    | text: ' ' |    | text: 2   |
+-----------+   +-----------+    +------------+    +-----------+    +-----------+
</code></pre>
<p>现在 syntax tree 已经包含了所有 source code 的信息，当然可以推断出每个 node 对应源代码的文本区间。</p>
<p>题主提到的 <a href="https://blog.walterlv.com/post/the-red-green-tree-of-roslyn.html">rust-analyzer/rowan</a> ，readme 中的第一句话</p>
<blockquote>
<p>Rowan is a library for lossless syntax trees</p>
</blockquote>
<p>lossless 指的应该就如我们上面所做的，source code 的任何东西都没有丢失，包括 whitespace，comments。</p>
<p>另一个有趣的事情是，现在的 syntax tree 有两个节点都是 whitespace，这两个节点有什么不同吗？没有任何不同，所以这两个节点是可以共用的。再比如 <code>1 + 1</code> 中的两个节点 <code>1</code> 也是可以共用的，这应该就是第 5 点“可重用”所要表达的意思吧。</p>
<blockquote>
<p>这种设计似乎可以应用在 lsp 中作为提高语言增量解析和构建的效率。</p>
</blockquote>
<p>那就以 lsp 为例谈一谈增量编译/计算。现在我们需要 lsp 帮我们做代码自动补全，流程大概像这样</p>
<ul>
<li>vscode：嘿，language server，帮我编辑器光标所在的位置做自动补全</li>
<li>language server: 收到。哈喽，type checker，帮我做一下类型检查</li>
<li>type checker: 好的，那我得先知道 AST</li>
<li>ast creater：没问题。嗨，parser，帮我生成一下 syntax tree</li>
<li>parser: 根据 source code 生成 syntax tree 。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-a0480cc5840280f58e321a44386bf645_720w.jpg" alt="image"></p>
<p>如果哪个过程发现本次计算的结果和上次的结果没有变化，就告诉它的调用方说，计算结果和之前没有变化，你不用再重新计算了。比如说我就只在代码中多加了一个 whitespace，那 syntax tree 不会发生变化，后面的 ast， type check 都不用重新算了，直接用之前缓存的结果就好。</p>
<p>增量计算的话可以看看 <a href="https://github.com/salsa-rs/salsa">Salsa</a>，rust-analyzer 用了这个库。</p>
<p>其实上面说的都是“绿树”部分。我觉得“红树”主要为了解决访问父节点的问题，另外也可以更方便算每个节点的 offset。</p>
<pre><code class="hljs language-Rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">SyntaxNode</span> = Arc&#x3C;SyntaxData>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SyntaxData</span> {
    offset: <span class="hljs-type">usize</span>,
    parent: <span class="hljs-type">Option</span>&#x3C;SyntaxNode>,
    green: Arc&#x3C;GreeNode>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">SyntaxNode</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new_root</span>(root: Arc&#x3C;GreenNode>) <span class="hljs-punctuation">-></span> SyntaxNode {
        Arc::<span class="hljs-title function_ invoke__">new</span>(SyntaxData {
            offset: <span class="hljs-number">0</span>,
            parent: <span class="hljs-literal">None</span>,
            green: root,
        })
    }
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">parent</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;SyntaxNode> {
        <span class="hljs-keyword">self</span>.parent.<span class="hljs-title function_ invoke__">clone</span>()
    }
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">children</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span>&#x3C;Item = SyntaxNode> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">offset</span> = <span class="hljs-keyword">self</span>.offset;
        <span class="hljs-keyword">self</span>.green.<span class="hljs-title function_ invoke__">children</span>().<span class="hljs-title function_ invoke__">map</span>(|green_child| {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">child_offset</span> = offset;
            offset += green_child.text_len;
            Arc::<span class="hljs-title function_ invoke__">new</span>(SyntaxData {
                offset: child_offset,
                parent: <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">clone</span>(<span class="hljs-keyword">self</span>)),
                green: Arc::<span class="hljs-title function_ invoke__">clone</span>(green_child),
            })
        })
    }
}
<span class="hljs-comment">// https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md</span>
</code></pre>
<p>用起来大概像这样</p>
<pre><code class="hljs language-Rust"><span class="hljs-comment">// 1 + 2</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">addition_red_node</span> = SyntaxNode::<span class="hljs-title function_ invoke__">new_root</span>(addtion_green_node);
<span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = addtion_red_node.<span class="hljs-title function_ invoke__">children</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwarp</span>()
<span class="hljs-built_in">println!</span>(one.<span class="hljs-title function_ invoke__">parent</span>().unwrap) <span class="hljs-comment">// syntax node bin_expr(1,plus, 2)</span>
</code></pre>
<p>另外注意到，红树的节点维护的都是指向绿树节点的 pointer/reference，构建红树并不需要对绿树做 deep copy，代价会比较小。</p>
<p>对于第 1 点 immutable，我不懂，希望懂的人指点。</p>
<p>Rust analyzer 的作者在 youtube 上讲过红绿树，用 rust 实现了一个简单的红绿树，推荐给各位 <a href="https://youtu.be/n5LDjWIAByM">https://youtu.be/n5LDjWIAByM</a></p></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"red_green_tree","contentHtml":"\u003cp\u003e本文源自我在知乎的一个回答，原文地址：\u003ca href=\"https://www.zhihu.com/question/525030607/answer/2418851335\"\u003ehttps://www.zhihu.com/question/525030607/answer/2418851335\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e原问题为：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e仓库：\u003ca href=\"https://github.com/rust-analyzer/rowan\"\u003ehttps://github.com/rust-analyzer/rowan\u003c/a\u003e\u003cbr\u003e\n参考文献：\u003ca href=\"https://blog.walterlv.com/post/the-red-green-tree-of-roslyn.html\"\u003e理解 Roslyn 中的红绿树（Red-Green Trees\u003c/a\u003e\u003cbr\u003e\n这种设计似乎可以应用在lsp中作为提高语言增量解析和构建的效率。\u003cbr\u003e\n不过尚未深刻理解其算法的精妙~\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e回答\u003c/h2\u003e\n\u003cp\u003e题主给了篇参考文章\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRoslyn 一开始就将漂亮的 API 作为目标的一部分，同时还要非常高的性能；所以 Roslyn 的开发团队需要找到一种特殊的数据结构来描述语言（如 C#）的语法。这种数据结构要满足这些期望的要求：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不可变（Immutable）\u003c/li\u003e\n\u003cli\u003e树的形式\u003c/li\u003e\n\u003cli\u003e可以容易地访问父节点和子节点\u003c/li\u003e\n\u003cli\u003e可以非常容易地将任何一个节点对应到源代码文件的一段文本区间\u003c/li\u003e\n\u003cli\u003e可重用（Persistent）\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e从第 4 点开始说，这是一个很常见的需求，想想我们的编译器报错信息，能够指出错误出现在源文件的哪一行哪一列。我们可能设计出下面这种数据结构作为 syntax tree\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[derive(PartialEq, Eq, Clone, Copy)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSyntaxKind\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu16\u003c/span\u003e);\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(PartialEq, Eq, Clone)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNode\u003c/span\u003e {\n    kind: SyntaxKind,\n    text_len: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e,\n    children: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Arc\u0026#x3C;Either\u0026#x3C;Node, Token\u003e\u003e\u003e,\n    offset: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(PartialEq, Eq, Clone)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eToken\u003c/span\u003e {\n    kind: SyntaxKind,\n    text: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n    offset: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003e1 + 2\u003c/code\u003e ，我们会得到如下的 syntax tree\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e               +-----------------+\n               |  Node           |\n               |  kind: BinExpr  |\n      +--------+  text_len: 5    +-------+\n      |        |  offset: 0      |       |\n      |        +-------+---------+       |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      v                v                 v\n+----------+    +------------+    +-----------+\n|Token     |    | Token      |    | Token     |\n|kind: int |    | kind: plus |    | kind: int |\n|text: 1   |    | text: +    |    | text: 2   |\n|offset: 0 |    | offset: 2  |    | offset: 4 |\n+----------+    +------------+    +-----------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果我们把 source code 简单改一下，多加一个 whitespace，即 \u003ccode\u003e1  + 2\u003c/code\u003e ，我们的 syntax tree 会发生变化吗？当然，从 + 开始所有节点的 offset 都要发生变化。真实场景中 source code 会复杂得多，加一个 whitespace，整个 syntax tree 就作废了。太浪费了，加 whitespace，加 comments 其实并不影响我们的 syntax，有没有方法使得语法无关的修改不改变 syntax tree 呢？\u003c/p\u003e\n\u003cp\u003e很容易能想到，我们的 node 不包含 offset 不就可以了吗？问题是如果不包含 offset，“任何一个节点对应到源代码文件的一段文本区间” 这条就不满足了。\u003c/p\u003e\n\u003cp\u003e我们可以把 whitespace 也放到 syntax tree 中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                               +---------------+\n                               | Node          |\n      +---------------+--------+ kind: BinExpr +---------+----------------+\n      |               |        | text_len: 5   |         |                |\n      |               |        +-------+-------+         |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      v               v                v                 v                v\n+-----------+   +-----------+    +------------+    +-----------+    +-----------+\n| Token     |   | Token     |    | Token      |    | Token     |    | Token     |\n| kind: int |   | kind: wp  |    | kind: plus |    | kind: wp  |    | kind: int |\n| text: 1   |   | text: ' ' |    | text: +    |    | text: ' ' |    | text: 2   |\n+-----------+   +-----------+    +------------+    +-----------+    +-----------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在 syntax tree 已经包含了所有 source code 的信息，当然可以推断出每个 node 对应源代码的文本区间。\u003c/p\u003e\n\u003cp\u003e题主提到的 \u003ca href=\"https://blog.walterlv.com/post/the-red-green-tree-of-roslyn.html\"\u003erust-analyzer/rowan\u003c/a\u003e ，readme 中的第一句话\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRowan is a library for lossless syntax trees\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003elossless 指的应该就如我们上面所做的，source code 的任何东西都没有丢失，包括 whitespace，comments。\u003c/p\u003e\n\u003cp\u003e另一个有趣的事情是，现在的 syntax tree 有两个节点都是 whitespace，这两个节点有什么不同吗？没有任何不同，所以这两个节点是可以共用的。再比如 \u003ccode\u003e1 + 1\u003c/code\u003e 中的两个节点 \u003ccode\u003e1\u003c/code\u003e 也是可以共用的，这应该就是第 5 点“可重用”所要表达的意思吧。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这种设计似乎可以应用在 lsp 中作为提高语言增量解析和构建的效率。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e那就以 lsp 为例谈一谈增量编译/计算。现在我们需要 lsp 帮我们做代码自动补全，流程大概像这样\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003evscode：嘿，language server，帮我编辑器光标所在的位置做自动补全\u003c/li\u003e\n\u003cli\u003elanguage server: 收到。哈喽，type checker，帮我做一下类型检查\u003c/li\u003e\n\u003cli\u003etype checker: 好的，那我得先知道 AST\u003c/li\u003e\n\u003cli\u003east creater：没问题。嗨，parser，帮我生成一下 syntax tree\u003c/li\u003e\n\u003cli\u003eparser: 根据 source code 生成 syntax tree 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://pic4.zhimg.com/80/v2-a0480cc5840280f58e321a44386bf645_720w.jpg\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e如果哪个过程发现本次计算的结果和上次的结果没有变化，就告诉它的调用方说，计算结果和之前没有变化，你不用再重新计算了。比如说我就只在代码中多加了一个 whitespace，那 syntax tree 不会发生变化，后面的 ast， type check 都不用重新算了，直接用之前缓存的结果就好。\u003c/p\u003e\n\u003cp\u003e增量计算的话可以看看 \u003ca href=\"https://github.com/salsa-rs/salsa\"\u003eSalsa\u003c/a\u003e，rust-analyzer 用了这个库。\u003c/p\u003e\n\u003cp\u003e其实上面说的都是“绿树”部分。我觉得“红树”主要为了解决访问父节点的问题，另外也可以更方便算每个节点的 offset。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSyntaxNode\u003c/span\u003e = Arc\u0026#x3C;SyntaxData\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSyntaxData\u003c/span\u003e {\n    offset: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e,\n    parent: \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;SyntaxNode\u003e,\n    green: Arc\u0026#x3C;GreeNode\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSyntaxNode\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enew_root\u003c/span\u003e(root: Arc\u0026#x3C;GreenNode\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e SyntaxNode {\n        Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(SyntaxData {\n            offset: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n            parent: \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e,\n            green: root,\n        })\n    }\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eparent\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;SyntaxNode\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.parent.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e()\n    }\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echildren\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = SyntaxNode\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoffset\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.offset;\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.green.\u003cspan class=\"hljs-title function_ invoke__\"\u003echildren\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003emap\u003c/span\u003e(|green_child| {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003echild_offset\u003c/span\u003e = offset;\n            offset += green_child.text_len;\n            Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(SyntaxData {\n                offset: child_offset,\n                parent: \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e)),\n                green: Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(green_child),\n            })\n        })\n    }\n}\n\u003cspan class=\"hljs-comment\"\u003e// https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用起来大概像这样\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 1 + 2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eaddition_red_node\u003c/span\u003e = SyntaxNode::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew_root\u003c/span\u003e(addtion_green_node);\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eone\u003c/span\u003e = addtion_red_node.\u003cspan class=\"hljs-title function_ invoke__\"\u003echildren\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwarp\u003c/span\u003e()\n\u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(one.\u003cspan class=\"hljs-title function_ invoke__\"\u003eparent\u003c/span\u003e().unwrap) \u003cspan class=\"hljs-comment\"\u003e// syntax node bin_expr(1,plus, 2)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e另外注意到，红树的节点维护的都是指向绿树节点的 pointer/reference，构建红树并不需要对绿树做 deep copy，代价会比较小。\u003c/p\u003e\n\u003cp\u003e对于第 1 点 immutable，我不懂，希望懂的人指点。\u003c/p\u003e\n\u003cp\u003eRust analyzer 的作者在 youtube 上讲过红绿树，用 rust 实现了一个简单的红绿树，推荐给各位 \u003ca href=\"https://youtu.be/n5LDjWIAByM\"\u003ehttps://youtu.be/n5LDjWIAByM\u003c/a\u003e\u003c/p\u003e","title":"如何看待 rust 体系中 rowan 的红绿树","date":"2022-04-01"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"red_green_tree"},"buildId":"EEU_erGoU_JDwBtAMKr2I","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>