<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>如何实现一个Rust Language Server?</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/7eb40cdb0d262f08.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7eb40cdb0d262f08.css" data-n-g=""/><link rel="preload" href="/_next/static/css/efe113e632f4289b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/efe113e632f4289b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-d719a31ca00eb19c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fcb060ba8fa2b368.js" defer=""></script><script src="/_next/static/chunks/640-1a3a0dc0790efd2e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-03d1a37039c741de.js" defer=""></script><script src="/_next/static/lVwdO_AUP_6FOgoxmHd6A/_buildManifest.js" defer=""></script><script src="/_next/static/lVwdO_AUP_6FOgoxmHd6A/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><main><article><h1 class="utils_headingXl__u25Y2">如何实现一个Rust Language Server?</h1><div class="utils_lightText__eUzGY"><time dateTime="2021-10-24">October 24, 2021</time></div><div><p>标题听起来像是一个教程，但它真的只是一个问题，是我问自己的一个问题，这篇文章记录我初步的思考。</p>
<p>先说说为什么会有这个问题吧，我觉得还挺有意思的。最近在看 <a href="https://github.com/rust-lang/rust-analyzer">RA（Rust
Analyzer）</a> 的源码，对 RA 的整体架构有了基本的认识，也提过一些 pr，但不知道接下来该怎么深入，迷茫之际，脑袋里突然蹦出这么一个问题：如果我去实现一个 Rust LS（languageserver），该怎么设计呢？</p>
<h2>如何实现</h2>
<p>实现一个 Rust LS。太复杂了，包括代码高亮、自动补全、定义跳转、Find Usages。</p>
<p>实现一个只有自动补全功能的 LS。再简化下，把自动补全功能限制在单个 rust 文件中，
也就是不考虑 workspace 中有多个 crate，甚至多个文件的情况。</p>
<p>实现一个能在单个 rust 文件中自动补全的 LS。自动补全些什么呢？对 rust 来说，要补全 keyword、built-in type、function、struct、trait、macro、attribute。太多了，不如把自动补全限制在 keyword、built-in type 以及用户自定义的 function 和 struct
上。</p>
<p>别管是通过磁盘 IO 读取 rust 文件还是 client 发送给我们，我们的输入就是一个字符串。</p>
<p>最后，再把问题明确一下，输入是一个字符串，包含 rust 代码以及一个表示光标所在位置的符号，输出是自动补全的建议，只针对 keyword、build-in type 以及用户自定义
function 和 struct。</p>
<pre><code class="hljs language-vbnet"><span class="hljs-symbol">Inputs:</span>
st$<span class="hljs-number">0</span>

<span class="hljs-symbol">Suggestions:</span>
struct
<span class="hljs-keyword">static</span>
</code></pre>
<p>上面的例子是说输入是“st$0”，“st”是 rust 代码，“$0”表示光标位置，意思是当键盘敲击
“st”时，应该补全为“struct”或者“static”。</p>
<h2>如何实现</h2>
<p>keyword 和 built-in type 比较容易，建个 hash 表，字符串匹配就行，那对于 function
和 struct 呢？也能用字符串匹配吗？</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(<span class="hljs-keyword">self</span>) {}
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">f</span> = Foo;
    f.$<span class="hljs-number">0</span>;
}
</code></pre>
<p>对于上述情况，字符串匹配应该匹配啥呢？</p>
<pre><code class="hljs language-rust"><span class="hljs-comment">//foo.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(<span class="hljs-keyword">self</span>) {}

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baz</span>(<span class="hljs-keyword">self</span>) {}
}

<span class="hljs-comment">//main.rs</span>
<span class="hljs-keyword">mod</span> foo;
<span class="hljs-keyword">use</span> foo::Foo;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">f</span> = Foo;
    f.$<span class="hljs-number">0</span>;
}
</code></pre>
<p>这里应该建议补全 f.baz 吗？baz 作为一个私有方法，在 main.rs 中是没有权限访问的
（虽然在上一节限制了只考虑单个文件，但这里还是想提一下）。在 RA 中会给出补全
f.bar 和 f.baz 的建议，补全后会给出"associated function baz is private"的
error。也不知道这是个 bug，还是故意这么设计的。但无关紧要，这里想说的是，字符串匹配不足以实现自动补全。通过上面的例子，实现自动补全似乎需要知道 f 是一个
struct，该 struct 有哪些方法，哪些 field？甚至每个方法，每个 field 的
visibility。</p>
<p>如果我们有了 AST，能完成自动补全吗？</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> {
    first: <span class="hljs-type">i32</span>,
    second: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(<span class="hljs-keyword">self</span>) {}
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baz</span>(<span class="hljs-keyword">self</span>) {}
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">foo</span> = Foo {
        first: <span class="hljs-number">0</span>,
        second: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello"</span>),
    };
    foo.$<span class="hljs-number">0</span>
}
</code></pre>
<p>假设上述代码的 AST 如下</p>
<p><img src="/13/ast.png" alt=""></p>
<p>AST 已经有足够的信息去做 struct 的自动补全，遍历 AST 可以知道 foo 是一个 Struct
Foo，再遍历 AST 可以知道 Foo 有哪些 field，哪些 method。最终给出自动补全的建议</p>
<pre><code class="hljs language-scss">first
second
<span class="hljs-built_in">bar</span>()
<span class="hljs-built_in">baz</span>()
</code></pre>
<p>Rust Analyzer 是怎么做的？RA 的做法和我上面说的没有本质不同，下面简单聊聊 RA 中额外的东西</p>
<blockquote>
<p>2022.12.17：今天再读，感觉 “RA 的做法和我上面说的没有本质不同” 这个结论是有很大问题的，RA 做了编译器前端需要做的一切事情，包括 name resolution，type check
等等</p>
</blockquote>
<h3>易用性</h3>
<p>首先是为了易用性，RA 在 AST 上再包了一层。怎么理解呢，假设 AST 中非叶子节点的定义是</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
    kind: Kind,
    text: <span class="hljs-type">String</span>,
    children: <span class="hljs-type">Vec</span>&#x3C;Either&#x3C;Node, Token>>
}
</code></pre>
<p>对于 Foo</p>
<pre><code class="hljs language-arduino">Node { kind: Kind::Struct, text: <span class="hljs-string">"Foo"</span>.<span class="hljs-built_in">to_string</span>(), children: vec![first, second, bar, baz] }
</code></pre>
<p>无论是一个 struct，还是一个 function，又或者是一个 trait，在 AST 中它们都只是
Node，类型是相同的，要得到 struct 的 field、method，或是得到 function 的
parameter、return type 都只能通过遍历 children。</p>
<p>对于 struct，RA 定义了类似下面的数据类型</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span> {
    node: Node
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Struct</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fields</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span>&#x3C;Item = Field> {} 
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_field</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> Field {} 
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">methods</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span>&#x3C;Item = Method> {}
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_method</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> Method {}
    ...
}
</code></pre>
<p>把 Foo 对应的 Node 转换成一个 Struct，对一个 Struct 操作比对一个 Node 操作要方便的多。</p>
<h3>性能优化</h3>
<p>每次找一个 node 都需要遍历 AST 吗？在 IDE 中敲代码，每个小改动都要重新分析一遍所有代码吗？</p>
<p>事实是大多数的改动都非常小，我们之前的一些计算结果并不需要抛弃。得益于 salsa
，RA 实现了增量计算，对于 salsa 的细节，我也搞不清楚，<a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/guide.md#salsa">https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/guide.md#salsa</a>
high level 的讲了 salsa 是如何工作的。</p>
<p>之后应该会去研究一下 salsa，再来分享</p></div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"13_rust_launguage_server","contentHtml":"\u003cp\u003e标题听起来像是一个教程，但它真的只是一个问题，是我问自己的一个问题，这篇文章记录我初步的思考。\u003c/p\u003e\n\u003cp\u003e先说说为什么会有这个问题吧，我觉得还挺有意思的。最近在看 \u003ca href=\"https://github.com/rust-lang/rust-analyzer\"\u003eRA（Rust\nAnalyzer）\u003c/a\u003e 的源码，对 RA 的整体架构有了基本的认识，也提过一些 pr，但不知道接下来该怎么深入，迷茫之际，脑袋里突然蹦出这么一个问题：如果我去实现一个 Rust LS（languageserver），该怎么设计呢？\u003c/p\u003e\n\u003ch2\u003e如何实现\u003c/h2\u003e\n\u003cp\u003e实现一个 Rust LS。太复杂了，包括代码高亮、自动补全、定义跳转、Find Usages。\u003c/p\u003e\n\u003cp\u003e实现一个只有自动补全功能的 LS。再简化下，把自动补全功能限制在单个 rust 文件中，\n也就是不考虑 workspace 中有多个 crate，甚至多个文件的情况。\u003c/p\u003e\n\u003cp\u003e实现一个能在单个 rust 文件中自动补全的 LS。自动补全些什么呢？对 rust 来说，要补全 keyword、built-in type、function、struct、trait、macro、attribute。太多了，不如把自动补全限制在 keyword、built-in type 以及用户自定义的 function 和 struct\n上。\u003c/p\u003e\n\u003cp\u003e别管是通过磁盘 IO 读取 rust 文件还是 client 发送给我们，我们的输入就是一个字符串。\u003c/p\u003e\n\u003cp\u003e最后，再把问题明确一下，输入是一个字符串，包含 rust 代码以及一个表示光标所在位置的符号，输出是自动补全的建议，只针对 keyword、build-in type 以及用户自定义\nfunction 和 struct。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-vbnet\"\u003e\u003cspan class=\"hljs-symbol\"\u003eInputs:\u003c/span\u003e\nst$\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-symbol\"\u003eSuggestions:\u003c/span\u003e\nstruct\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的例子是说输入是“st$0”，“st”是 rust 代码，“$0”表示光标位置，意思是当键盘敲击\n“st”时，应该补全为“struct”或者“static”。\u003c/p\u003e\n\u003ch2\u003e如何实现\u003c/h2\u003e\n\u003cp\u003ekeyword 和 built-in type 比较容易，建个 hash 表，字符串匹配就行，那对于 function\n和 struct 呢？也能用字符串匹配吗？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {}\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ef\u003c/span\u003e = Foo;\n    f.$\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于上述情况，字符串匹配应该匹配啥呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e//foo.rs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {}\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebaz\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {}\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//main.rs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e foo;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e foo::Foo;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ef\u003c/span\u003e = Foo;\n    f.$\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里应该建议补全 f.baz 吗？baz 作为一个私有方法，在 main.rs 中是没有权限访问的\n（虽然在上一节限制了只考虑单个文件，但这里还是想提一下）。在 RA 中会给出补全\nf.bar 和 f.baz 的建议，补全后会给出\"associated function baz is private\"的\nerror。也不知道这是个 bug，还是故意这么设计的。但无关紧要，这里想说的是，字符串匹配不足以实现自动补全。通过上面的例子，实现自动补全似乎需要知道 f 是一个\nstruct，该 struct 有哪些方法，哪些 field？甚至每个方法，每个 field 的\nvisibility。\u003c/p\u003e\n\u003cp\u003e如果我们有了 AST，能完成自动补全吗？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e {\n    first: \u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e,\n    second: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {}\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebaz\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {}\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003efoo\u003c/span\u003e = Foo {\n        first: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n        second: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e),\n    };\n    foo.$\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e假设上述代码的 AST 如下\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/13/ast.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eAST 已经有足够的信息去做 struct 的自动补全，遍历 AST 可以知道 foo 是一个 Struct\nFoo，再遍历 AST 可以知道 Foo 有哪些 field，哪些 method。最终给出自动补全的建议\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scss\"\u003efirst\nsecond\n\u003cspan class=\"hljs-built_in\"\u003ebar\u003c/span\u003e()\n\u003cspan class=\"hljs-built_in\"\u003ebaz\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRust Analyzer 是怎么做的？RA 的做法和我上面说的没有本质不同，下面简单聊聊 RA 中额外的东西\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e2022.12.17：今天再读，感觉 “RA 的做法和我上面说的没有本质不同” 这个结论是有很大问题的，RA 做了编译器前端需要做的一切事情，包括 name resolution，type check\n等等\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e易用性\u003c/h3\u003e\n\u003cp\u003e首先是为了易用性，RA 在 AST 上再包了一层。怎么理解呢，假设 AST 中非叶子节点的定义是\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNode\u003c/span\u003e {\n    kind: Kind,\n    text: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n    children: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Either\u0026#x3C;Node, Token\u003e\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 Foo\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-arduino\"\u003eNode { kind: Kind::Struct, text: \u003cspan class=\"hljs-string\"\u003e\"Foo\"\u003c/span\u003e.\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(), children: vec![first, second, bar, baz] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e无论是一个 struct，还是一个 function，又或者是一个 trait，在 AST 中它们都只是\nNode，类型是相同的，要得到 struct 的 field、method，或是得到 function 的\nparameter、return type 都只能通过遍历 children。\u003c/p\u003e\n\u003cp\u003e对于 struct，RA 定义了类似下面的数据类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStruct\u003c/span\u003e {\n    node: Node\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStruct\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efields\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Field\u003e {} \n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efirst_field\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Field {} \n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emethods\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Method\u003e {}\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efirst_method\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Method {}\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e把 Foo 对应的 Node 转换成一个 Struct，对一个 Struct 操作比对一个 Node 操作要方便的多。\u003c/p\u003e\n\u003ch3\u003e性能优化\u003c/h3\u003e\n\u003cp\u003e每次找一个 node 都需要遍历 AST 吗？在 IDE 中敲代码，每个小改动都要重新分析一遍所有代码吗？\u003c/p\u003e\n\u003cp\u003e事实是大多数的改动都非常小，我们之前的一些计算结果并不需要抛弃。得益于 salsa\n，RA 实现了增量计算，对于 salsa 的细节，我也搞不清楚，\u003ca href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/guide.md#salsa\"\u003ehttps://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/guide.md#salsa\u003c/a\u003e\nhigh level 的讲了 salsa 是如何工作的。\u003c/p\u003e\n\u003cp\u003e之后应该会去研究一下 salsa，再来分享\u003c/p\u003e","title":"如何实现一个Rust Language Server?","date":"2021-10-24"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"13_rust_launguage_server"},"buildId":"lVwdO_AUP_6FOgoxmHd6A","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>