<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>《Crafting Interpreters》阅读笔记（三）</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/ab65974685f462b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab65974685f462b8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/xMMIyFmIcavYloJec1vbp/_buildManifest.js" defer=""></script><script src="/_next/static/xMMIyFmIcavYloJec1vbp/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">《Crafting Interpreters》阅读笔记（三）</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2021-10-24">October 24, 2021</time></div><div><p><a href="http://www.craftinginterpreters.com/">《Crafting Interpreters》</a>中 clox（Part 2 中用 C 实现的 Lox 语言）实现了 <a href="http://www.craftinginterpreters.com/compiling-expressions.html#a-pratt-parser">Pratt Parser</a>。<a href="crafting_interpreters_2">上一篇文章</a>讲了 RD（Recursive Descent Parsing），个人感觉 Pratt Parsing 也是属于 RD 的，是 RD 的一个改进。</p>
<p>上篇文章中提到了 parsing 要解决的两个问题</p>
<ul>
<li>不同运算符的优先级，比如 <code>*</code> 比 <code>+</code> 的优先级高，<code>1 + 2 * 3</code> 应该被 parse 为 <code>1 + (2 * 3)</code></li>
<li>Associativity，比如 <code>+</code> 是 left-associative 的， <code>1 + 2 + 3</code> 应该被 parse 为 <code>(1 + 2) + 3</code>，而赋值 <code>=</code> 是 right-associative 的，<code>a = b = c</code> 应该被 parse 为 <code>a = (b = c)</code>。</li>
</ul>
<p>RD 中每个优先级都在语法规则中占一个 level，对应到代码中，每个优先级都会对应一个单独的函数，优先级低的函数先被调用，每个函数都会调用比自己优先级更高一级的函数，通过这种方式解决不同运算符的优先级问题。至于 Associativity，是通过是否在函数中递归调用自身解决的。</p>
<p>当语法写成下面这种形式时，表示 Int 比 Plus 的优先级高，函数 plus 会调用 int，且 <code>+</code> 是 left-associative 的。</p>
<pre><code>Plus -> Int {+ Int }
</code></pre>
<p>把语法改下，写成</p>
<pre><code>Plus -> Int + Plus
</code></pre>
<p>这样的话，函数 plus 不仅会调用 int，还会调用自身。Int 的优先级仍然比 Plus 高，但是 <code>+ </code>变成了 right-associative 的。</p>
<p>RD 对语法的定义很严格，得很小心的去写，避免把 left-associative 和 right-associative 搞错。你还得很小心的写，避免弄出 left recursion。。。比如不能写成下面这样</p>
<pre><code>Plus -> Plus + Int
</code></pre>
<p>另外，RD 每个优先级都对应一个函数，运行效率很低，即使只是 parse 一个 token，也需要调用多个层级的函数。</p>
<p>Pratt Parsing 很优雅的解决了 RD 中的这些问题，没有那么多层级，通过比较当前运算符和上一个运算符的优先级来确定哪个运算符应该先算。</p>
<pre><code>  1   +   2   *   3
0   1   1   2   2   0
</code></pre>
<p>同样通过给运算符左右两侧赋予不一样的值，就可以实现 left-associative 和 right-associative</p>
<pre><code>  1     +     2     +   3
0   1.1    1    1.1   1   0
</code></pre>
<p>对于 Pratt Parsing，我发现了一篇神文，看过几篇写 Pratt Parsing 的文章，没有哪一篇将 Pratt Parsing 写得如此清晰。</p>
<p><a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">Simple but Powerful Pratt Parsing</a></p>
<p>作者是 rust-analyzer 的作者 matklad，rust-analyzer 中的 parser 用的就是 Pratt Parsing。</p>
<p>比较好笑的是 matklad 说写这篇文章的原因是他经常看不懂自己在 rust-analyzer 中写的 pratt parsing 代码</p>
<blockquote>
<p>Understanding the algorithm myself for hopefully the last time. I’ve implemented a production-grade Pratt parser once, but I no longer immediately understand that code :-)</p>
</blockquote>
<p>既然 matklad 已经写得这么好了，我就没必要再写了:-），主要还是因为懒，写这个真的很费劲。另外感觉自己也没有啥额外的东西可写，写的话很可能写成 matklad 文章的翻译。</p>
<p>上篇文章用 RD 实现了加减乘除计算器的 parser，这里贴一下 Pratt Parsing 的实现，代码很简单，看看有助于理解</p>
<pre><code class="hljs language-Rust"><span class="hljs-keyword">use</span> std::fmt;
<span class="hljs-keyword">use</span> std::iter::Peekable;

<span class="hljs-meta">#[derive(Debug, Clone)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Token</span> {
    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">u32</span>),
    Plus,
    Minus,
    Star,
    Slash,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Token</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&#x26;<span class="hljs-keyword">self</span>, f: &#x26;<span class="hljs-keyword">mut</span> fmt::Formatter&#x3C;<span class="hljs-symbol">'_</span>>) <span class="hljs-punctuation">-></span> fmt::<span class="hljs-type">Result</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            Token::<span class="hljs-title function_ invoke__">Number</span>(n) => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{}"</span>, n),
            Token::Plus => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"+"</span>),
            Token::Minus => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"-"</span>),
            Token::Star => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"*"</span>),
            Token::Slash => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"/"</span>),
        }
    }
}

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Expr</span> {
    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">u32</span>),
    <span class="hljs-title function_ invoke__">Binary</span>(<span class="hljs-type">Box</span>&#x3C;Expr>, Token, <span class="hljs-type">Box</span>&#x3C;Expr>),
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Expr</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&#x26;<span class="hljs-keyword">self</span>, f: &#x26;<span class="hljs-keyword">mut</span> fmt::Formatter&#x3C;<span class="hljs-symbol">'_</span>>) <span class="hljs-punctuation">-></span> fmt::<span class="hljs-type">Result</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            Expr::<span class="hljs-title function_ invoke__">Number</span>(n) => <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{}"</span>, n),
            Expr::<span class="hljs-title function_ invoke__">Binary</span>(lhs, token, rhs) => {
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"({} "</span>, lhs)?;
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{} "</span>, token)?;
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">"{})"</span>, rhs)
            }
        }
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">expr_bp</span>&#x3C;I: <span class="hljs-built_in">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class="hljs-keyword">mut</span> Peekable&#x3C;I>, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-></span> Expr {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> token_iter.<span class="hljs-title function_ invoke__">peek</span>() {
        <span class="hljs-title function_ invoke__">Some</span>(Token::<span class="hljs-title function_ invoke__">Number</span>(it)) => Expr::<span class="hljs-title function_ invoke__">Number</span>(*it),
        <span class="hljs-title function_ invoke__">Some</span>(token) => <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"bad token: {:?}"</span>, token),
        <span class="hljs-literal">None</span> => <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"no more tokens left"</span>),
    };
    token_iter.<span class="hljs-title function_ invoke__">next</span>();

    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(token) = token_iter.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">cloned</span>() {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Token</span>::<span class="hljs-title function_ invoke__">Number</span>(_) = token {
            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"bad token: {:?}"</span>, token)
        }

        <span class="hljs-keyword">let</span> (l_bp, r_bp) = <span class="hljs-title function_ invoke__">infix_binding_power</span>(token.<span class="hljs-title function_ invoke__">clone</span>());
        <span class="hljs-keyword">if</span> l_bp &#x3C; min_bp {
            <span class="hljs-keyword">break</span>;
        }

        token_iter.<span class="hljs-title function_ invoke__">next</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">rhs</span> = <span class="hljs-title function_ invoke__">expr_bp</span>(token_iter, r_bp);
        lhs = Expr::<span class="hljs-title function_ invoke__">Binary</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(lhs), token.<span class="hljs-title function_ invoke__">clone</span>(), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(rhs));
    }
    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">infix_binding_power</span>(op: Token) <span class="hljs-punctuation">-></span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        Token::Plus | Token::Minus => (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        Token::Star | Token::Slash => (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        _ => <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"bad op: {:?}"</span>, op),
    }
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">tokens</span> = <span class="hljs-built_in">vec!</span>[
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1</span>),
        Token::Plus,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">2</span>),
        Token::Slash,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">3</span>),
    ];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">expr_bp</span>(&#x26;<span class="hljs-keyword">mut</span> tokens.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">peekable</span>(), <span class="hljs-number">0</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">"(1 + (2 / 3))"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-variable">tokens</span> = <span class="hljs-built_in">vec!</span>[
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1</span>),
        Token::Minus,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">2</span>),
        Token::Plus,
        Token::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">3</span>),
    ];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">expr_bp</span>(&#x26;<span class="hljs-keyword">mut</span> tokens.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">peekable</span>(), <span class="hljs-number">0</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">"((1 - 2) + 3)"</span>);
</code></pre></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"crafting_interpreters_3","contentHtml":"\u003cp\u003e\u003ca href=\"http://www.craftinginterpreters.com/\"\u003e《Crafting Interpreters》\u003c/a\u003e中 clox（Part 2 中用 C 实现的 Lox 语言）实现了 \u003ca href=\"http://www.craftinginterpreters.com/compiling-expressions.html#a-pratt-parser\"\u003ePratt Parser\u003c/a\u003e。\u003ca href=\"crafting_interpreters_2\"\u003e上一篇文章\u003c/a\u003e讲了 RD（Recursive Descent Parsing），个人感觉 Pratt Parsing 也是属于 RD 的，是 RD 的一个改进。\u003c/p\u003e\n\u003cp\u003e上篇文章中提到了 parsing 要解决的两个问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不同运算符的优先级，比如 \u003ccode\u003e*\u003c/code\u003e 比 \u003ccode\u003e+\u003c/code\u003e 的优先级高，\u003ccode\u003e1 + 2 * 3\u003c/code\u003e 应该被 parse 为 \u003ccode\u003e1 + (2 * 3)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eAssociativity，比如 \u003ccode\u003e+\u003c/code\u003e 是 left-associative 的， \u003ccode\u003e1 + 2 + 3\u003c/code\u003e 应该被 parse 为 \u003ccode\u003e(1 + 2) + 3\u003c/code\u003e，而赋值 \u003ccode\u003e=\u003c/code\u003e 是 right-associative 的，\u003ccode\u003ea = b = c\u003c/code\u003e 应该被 parse 为 \u003ccode\u003ea = (b = c)\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRD 中每个优先级都在语法规则中占一个 level，对应到代码中，每个优先级都会对应一个单独的函数，优先级低的函数先被调用，每个函数都会调用比自己优先级更高一级的函数，通过这种方式解决不同运算符的优先级问题。至于 Associativity，是通过是否在函数中递归调用自身解决的。\u003c/p\u003e\n\u003cp\u003e当语法写成下面这种形式时，表示 Int 比 Plus 的优先级高，函数 plus 会调用 int，且 \u003ccode\u003e+\u003c/code\u003e 是 left-associative 的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlus -\u003e Int {+ Int }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e把语法改下，写成\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlus -\u003e Int + Plus\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样的话，函数 plus 不仅会调用 int，还会调用自身。Int 的优先级仍然比 Plus 高，但是 \u003ccode\u003e+ \u003c/code\u003e变成了 right-associative 的。\u003c/p\u003e\n\u003cp\u003eRD 对语法的定义很严格，得很小心的去写，避免把 left-associative 和 right-associative 搞错。你还得很小心的写，避免弄出 left recursion。。。比如不能写成下面这样\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlus -\u003e Plus + Int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e另外，RD 每个优先级都对应一个函数，运行效率很低，即使只是 parse 一个 token，也需要调用多个层级的函数。\u003c/p\u003e\n\u003cp\u003ePratt Parsing 很优雅的解决了 RD 中的这些问题，没有那么多层级，通过比较当前运算符和上一个运算符的优先级来确定哪个运算符应该先算。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  1   +   2   *   3\n0   1   1   2   2   0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同样通过给运算符左右两侧赋予不一样的值，就可以实现 left-associative 和 right-associative\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  1     +     2     +   3\n0   1.1    1    1.1   1   0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 Pratt Parsing，我发现了一篇神文，看过几篇写 Pratt Parsing 的文章，没有哪一篇将 Pratt Parsing 写得如此清晰。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html\"\u003eSimple but Powerful Pratt Parsing\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e作者是 rust-analyzer 的作者 matklad，rust-analyzer 中的 parser 用的就是 Pratt Parsing。\u003c/p\u003e\n\u003cp\u003e比较好笑的是 matklad 说写这篇文章的原因是他经常看不懂自己在 rust-analyzer 中写的 pratt parsing 代码\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUnderstanding the algorithm myself for hopefully the last time. I’ve implemented a production-grade Pratt parser once, but I no longer immediately understand that code :-)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e既然 matklad 已经写得这么好了，我就没必要再写了:-），主要还是因为懒，写这个真的很费劲。另外感觉自己也没有啥额外的东西可写，写的话很可能写成 matklad 文章的翻译。\u003c/p\u003e\n\u003cp\u003e上篇文章用 RD 实现了加减乘除计算器的 parser，这里贴一下 Pratt Parsing 的实现，代码很简单，看看有助于理解\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::fmt;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::iter::Peekable;\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug, Clone)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eToken\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e),\n    Plus,\n    Minus,\n    Star,\n    Slash,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003efmt\u003c/span\u003e::Display \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eToken\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efmt\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, f: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e fmt::Formatter\u0026#x3C;\u003cspan class=\"hljs-symbol\"\u003e'_\u003c/span\u003e\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e fmt::\u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e {\n            Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(n) =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, n),\n            Token::Plus =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"+\"\u003c/span\u003e),\n            Token::Minus =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"-\"\u003c/span\u003e),\n            Token::Star =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e),\n            Token::Slash =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e),\n        }\n    }\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[derive(Debug)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExpr\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e\u0026#x3C;Expr\u003e, Token, \u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e\u0026#x3C;Expr\u003e),\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003efmt\u003c/span\u003e::Display \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExpr\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efmt\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, f: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e fmt::Formatter\u0026#x3C;\u003cspan class=\"hljs-symbol\"\u003e'_\u003c/span\u003e\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e fmt::\u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e {\n            Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(n) =\u003e \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, n),\n            Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(lhs, token, rhs) =\u003e {\n                \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"({} \"\u003c/span\u003e, lhs)?;\n                \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{} \"\u003c/span\u003e, token)?;\n                \u003cspan class=\"hljs-built_in\"\u003ewrite!\u003c/span\u003e(f, \u003cspan class=\"hljs-string\"\u003e\"{})\"\u003c/span\u003e, rhs)\n            }\n        }\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexpr_bp\u003c/span\u003e\u0026#x3C;I: \u003cspan class=\"hljs-built_in\"\u003eIterator\u003c/span\u003e\u0026#x3C;Item = Token\u003e\u003e(token_iter: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e Peekable\u0026#x3C;I\u003e, min_bp: \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Expr {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003elhs\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003epeek\u003c/span\u003e() {\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(it)) =\u003e Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(*it),\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(token) =\u003e \u003cspan class=\"hljs-built_in\"\u003epanic!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bad token: {:?}\"\u003c/span\u003e, token),\n        \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003epanic!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"no more tokens left\"\u003c/span\u003e),\n    };\n    token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(token) = token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003epeek\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003ecloned\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eToken\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(_) = token {\n            \u003cspan class=\"hljs-built_in\"\u003epanic!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bad token: {:?}\"\u003c/span\u003e, token)\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (l_bp, r_bp) = \u003cspan class=\"hljs-title function_ invoke__\"\u003einfix_binding_power\u003c/span\u003e(token.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e());\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e l_bp \u0026#x3C; min_bp {\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n        }\n\n        token_iter.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erhs\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eexpr_bp\u003c/span\u003e(token_iter, r_bp);\n        lhs = Expr::\u003cspan class=\"hljs-title function_ invoke__\"\u003eBinary\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(lhs), token.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(), \u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(rhs));\n    }\n    lhs\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einfix_binding_power\u003c/span\u003e(op: Token) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e op {\n        Token::Plus | Token::Minus =\u003e (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n        Token::Star | Token::Slash =\u003e (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e),\n        _ =\u003e \u003cspan class=\"hljs-built_in\"\u003epanic!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bad op: {:?}\"\u003c/span\u003e, op),\n    }\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[test]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etests\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etokens\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n        Token::Plus,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n        Token::Slash,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e),\n    ];\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eexpr_bp\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e tokens.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003epeekable\u003c/span\u003e(), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(s.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(), \u003cspan class=\"hljs-string\"\u003e\"(1 + (2 / 3))\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etokens\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n        Token::Minus,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n        Token::Plus,\n        Token::\u003cspan class=\"hljs-title function_ invoke__\"\u003eNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e),\n    ];\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eexpr_bp\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e tokens.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003epeekable\u003c/span\u003e(), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(s.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(), \u003cspan class=\"hljs-string\"\u003e\"((1 - 2) + 3)\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e","title":"《Crafting Interpreters》阅读笔记（三）","date":"2021-10-24"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"crafting_interpreters_3"},"buildId":"xMMIyFmIcavYloJec1vbp","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>