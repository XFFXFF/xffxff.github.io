<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>WIP: Salsa: The red green algorithm</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/7eb40cdb0d262f08.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7eb40cdb0d262f08.css" data-n-g=""/><link rel="preload" href="/_next/static/css/69a316e8a13b4830.css" as="style"/><link rel="stylesheet" href="/_next/static/css/69a316e8a13b4830.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-d719a31ca00eb19c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fcb060ba8fa2b368.js" defer=""></script><script src="/_next/static/chunks/640-1a3a0dc0790efd2e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-03d1a37039c741de.js" defer=""></script><script src="/_next/static/W6dv5dhgSa2IB4EZLfIGo/_buildManifest.js" defer=""></script><script src="/_next/static/W6dv5dhgSa2IB4EZLfIGo/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><main><article><h1 class="utils_headingXl__u25Y2">WIP: Salsa: The red green algorithm</h1><div class="utils_lightText__eUzGY"><time dateTime="2022-12-23">December 23, 2022</time></div><div><blockquote>
<p>The goal of Salsa is to support efficient incremental recomputation. Salsa is used in rust-analyzer, for example, to help it recompile your program quickly as you type.</p>
<p>The basic idea of a Salsa program is like this:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = ...;
<span class="hljs-keyword">loop</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output</span> = <span class="hljs-title function_ invoke__">your_program</span>(&#x26;input);
    <span class="hljs-title function_ invoke__">modify</span>(&#x26;<span class="hljs-keyword">mut</span> input);
}
</code></pre>
<p>You start out with an input that has some value. You invoke your program to get back a result. Some time later, you modify the input and invoke your program again. Our goal is to make this second call faster by re-using some of the results from the first call.</p>
<p>In reality, of course, you can have many inputs and "your program" may be many different methods and functions defined on those inputs. But this picture still conveys a few important concepts:</p>
<ul>
<li>Salsa separates out the "incremental computation" (the function <code>your_program</code>) from some outer loop that is defining the inputs.</li>
<li>Salsa gives you the tools to define <code>your_program</code>.</li>
<li>Salsa assumes that your_program is a purely deterministic function of its inputs, or else this whole setup makes no sense.</li>
<li>The mutation of inputs always happens outside of <code>your_program</code>, as part of this master loop.</li>
</ul>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::input]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyInput</span> {
    field: <span class="hljs-type">u32</span>,
}

<span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    <span class="hljs-title function_ invoke__">some_slow_fn</span>(input.<span class="hljs-title function_ invoke__">field</span>(db))
}
</code></pre>
<p>If the <code>input</code> isn't changed, the second call to <code>tracked_fn</code> doesn't need to recompute the result. But if the <code>input</code> is changed, no matter how small the change is and whether it affects the final result, the tracked struct is invalidated. This is not what we want. Even if the <code>input</code> is changed, we may benefit from the previous computation by reusing intermediate results to speed up this one. Take the compiler as an example, if we just add a space or a comment, the AST is not changed, all the following analysis can reuse the previous results.</p>
<p>What if we add some tracked functions to compute the intermediate results?</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::input]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyInput</span> {
    field: <span class="hljs-type">u32</span>,
}

<span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">final_result</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res1</span> = <span class="hljs-title function_ invoke__">intermediate_result1</span>(input);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res2</span> = <span class="hljs-title function_ invoke__">intermediate_restul2</span>(res1);
    ...
}

<span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">intermediate_result1</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    ...
} 

<span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">intermediate_result2</span>(db: &#x26;Db, input: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    ...
}
</code></pre></div></article></main><div class="layout_backToHome__9sjx_"><a href="/">‚Üê Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"14_salsa_red_green_algorithm","contentHtml":"\u003cblockquote\u003e\n\u003cp\u003eThe goal of Salsa is to support efficient incremental recomputation. Salsa is used in rust-analyzer, for example, to help it recompile your program quickly as you type.\u003c/p\u003e\n\u003cp\u003eThe basic idea of a Salsa program is like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput\u003c/span\u003e = ...;\n\u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eyour_program\u003c/span\u003e(\u0026#x26;input);\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003emodify\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e input);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou start out with an input that has some value. You invoke your program to get back a result. Some time later, you modify the input and invoke your program again. Our goal is to make this second call faster by re-using some of the results from the first call.\u003c/p\u003e\n\u003cp\u003eIn reality, of course, you can have many inputs and \"your program\" may be many different methods and functions defined on those inputs. But this picture still conveys a few important concepts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSalsa separates out the \"incremental computation\" (the function \u003ccode\u003eyour_program\u003c/code\u003e) from some outer loop that is defining the inputs.\u003c/li\u003e\n\u003cli\u003eSalsa gives you the tools to define \u003ccode\u003eyour_program\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eSalsa assumes that your_program is a purely deterministic function of its inputs, or else this whole setup makes no sense.\u003c/li\u003e\n\u003cli\u003eThe mutation of inputs always happens outside of \u003ccode\u003eyour_program\u003c/code\u003e, as part of this master loop.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::input]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyInput\u003c/span\u003e {\n    field: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003esome_slow_fn\u003c/span\u003e(input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the \u003ccode\u003einput\u003c/code\u003e isn't changed, the second call to \u003ccode\u003etracked_fn\u003c/code\u003e doesn't need to recompute the result. But if the \u003ccode\u003einput\u003c/code\u003e is changed, no matter how small the change is and whether it affects the final result, the tracked struct is invalidated. This is not what we want. Even if the \u003ccode\u003einput\u003c/code\u003e is changed, we may benefit from the previous computation by reusing intermediate results to speed up this one. Take the compiler as an example, if we just add a space or a comment, the AST is not changed, all the following analysis can reuse the previous results.\u003c/p\u003e\n\u003cp\u003eWhat if we add some tracked functions to compute the intermediate results?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::input]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyInput\u003c/span\u003e {\n    field: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efinal_result\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eres1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eintermediate_result1\u003c/span\u003e(input);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eres2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eintermediate_restul2\u003c/span\u003e(res1);\n    ...\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eintermediate_result1\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    ...\n} \n\n\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eintermediate_result2\u003c/span\u003e(db: \u0026#x26;Db, input: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e","title":"WIP: Salsa: The red green algorithm","date":"2022-12-23"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"14_salsa_red_green_algorithm"},"buildId":"W6dv5dhgSa2IB4EZLfIGo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>