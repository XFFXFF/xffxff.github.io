<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>Lox 实现日记：局部变量</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/ab65974685f462b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab65974685f462b8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/kvi89lrFpDDQo0VReVJIN/_buildManifest.js" defer=""></script><script src="/_next/static/kvi89lrFpDDQo0VReVJIN/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">Lox 实现日记：局部变量</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2023-09-26">September 26, 2023</time></div><div><p>本文介绍了 lox 中局部变量的实现原理，重点关注了如何通过 bytecode 来实现局部变量。</p>
<pre><code>{
    var a = 1;
    {
        var b = 2;
        print b;
    }
    print a;
}
</code></pre>
<p>局部变量的实现需要解决以下几个问题：</p>
<ul>
<li>声明/定义变量</li>
<li>读取变量</li>
<li>释放变量</li>
</ul>
<p>先来看看上述代码对应的 bytecode</p>
<pre><code>Constant(value: 1)
Constant(value: 2)
ReadLocal(index_in_stack: 1)
Print
PopStack
ReadLocal(index_in_stack: 0)
Print
PopStack
</code></pre>
<p>将源代码和 bytecode 对应起来</p>
<pre><code>{
    var a = 1;                           # Constant(value: 1)
    {
        var b = 2;                       # Constant(value: 2)
        print b;                         # ReadLocal(index_in_stack: 1), Print
    }                                    # PopStack
    print a;                             # ReadLocal(index_in_stack: 0), Print
}                                        # PopStack
</code></pre>
<p>不妨先试着执行一下这段 bytecode，看看会发生什么，重点关注栈的变化。</p>
<pre><code>Constant(value: 1)               push(1)                     # stack: [1]
Constant(value: 2)               push(2)                     # stack: [1, 2]
ReadLocal(index_in_stack: 1)     push(stack[1])              # stack: [1, 2, 2]
Print                            print(pop())                # stack: [1, 2]   output: 2
PopStack                         pop()                       # stack: [1]
ReadLocal(index_in_stack: 0)     push(stack[0])              # stack: [1, 1]
Print                            print(pop())                # stack: [1]      output: 1
PopStack                         pop()                       # stack: []
</code></pre>
<p>可以看到，这段 bytecode 的执行结果是符合预期的。</p>
<p>仔细观察 bytecode，有几个很有意思的地方</p>
<ul>
<li>在定义变量的时候，我们仅仅是将变量的值压入了栈中，变量的名字 <code>a</code> 和 <code>b</code> 并没有出现在 bytecode 中</li>
<li>在读取变量的时候，我们并没有指定变量的名字，而是指定了变量在栈中的位置，比如 <code>ReadLocal(index_in_stack: 1)</code>，这里的 <code>1</code> 表示变量在栈中的位置</li>
</ul>
<p>之所以能这样做，是因为我们在编译期就能确定局部变量在 stack 中的位置。</p></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"lox_implementation_note_1","contentHtml":"\u003cp\u003e本文介绍了 lox 中局部变量的实现原理，重点关注了如何通过 bytecode 来实现局部变量。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    var a = 1;\n    {\n        var b = 2;\n        print b;\n    }\n    print a;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e局部变量的实现需要解决以下几个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e声明/定义变量\u003c/li\u003e\n\u003cli\u003e读取变量\u003c/li\u003e\n\u003cli\u003e释放变量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e先来看看上述代码对应的 bytecode\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eConstant(value: 1)\nConstant(value: 2)\nReadLocal(index_in_stack: 1)\nPrint\nPopStack\nReadLocal(index_in_stack: 0)\nPrint\nPopStack\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将源代码和 bytecode 对应起来\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    var a = 1;                           # Constant(value: 1)\n    {\n        var b = 2;                       # Constant(value: 2)\n        print b;                         # ReadLocal(index_in_stack: 1), Print\n    }                                    # PopStack\n    print a;                             # ReadLocal(index_in_stack: 0), Print\n}                                        # PopStack\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e不妨先试着执行一下这段 bytecode，看看会发生什么，重点关注栈的变化。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eConstant(value: 1)               push(1)                     # stack: [1]\nConstant(value: 2)               push(2)                     # stack: [1, 2]\nReadLocal(index_in_stack: 1)     push(stack[1])              # stack: [1, 2, 2]\nPrint                            print(pop())                # stack: [1, 2]   output: 2\nPopStack                         pop()                       # stack: [1]\nReadLocal(index_in_stack: 0)     push(stack[0])              # stack: [1, 1]\nPrint                            print(pop())                # stack: [1]      output: 1\nPopStack                         pop()                       # stack: []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到，这段 bytecode 的执行结果是符合预期的。\u003c/p\u003e\n\u003cp\u003e仔细观察 bytecode，有几个很有意思的地方\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在定义变量的时候，我们仅仅是将变量的值压入了栈中，变量的名字 \u003ccode\u003ea\u003c/code\u003e 和 \u003ccode\u003eb\u003c/code\u003e 并没有出现在 bytecode 中\u003c/li\u003e\n\u003cli\u003e在读取变量的时候，我们并没有指定变量的名字，而是指定了变量在栈中的位置，比如 \u003ccode\u003eReadLocal(index_in_stack: 1)\u003c/code\u003e，这里的 \u003ccode\u003e1\u003c/code\u003e 表示变量在栈中的位置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e之所以能这样做，是因为我们在编译期就能确定局部变量在 stack 中的位置。\u003c/p\u003e","title":"Lox 实现日记：局部变量","date":"2023-09-26"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"lox_implementation_note_1"},"buildId":"kvi89lrFpDDQo0VReVJIN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>