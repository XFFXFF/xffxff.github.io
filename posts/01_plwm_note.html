<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>自顶向下编译</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/ab65974685f462b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab65974685f462b8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/_qgOuqiGxjUsSi8y35n2B/_buildManifest.js" defer=""></script><script src="/_next/static/_qgOuqiGxjUsSi8y35n2B/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">自顶向下编译</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2022-02-21">February 21, 2022</time></div><div><p>本文是 nikomatsakis 在 <a href="https://github.com/nikomatsakis/plmw-2022">PLWM 2022</a> 演讲的一点笔记。</p>
<p>传统编译器的工作模式是自底向上的。读取源代码，lexer 将源文本转换为一连串的 token，这些 token 输入给 parser ，parser 生成 syntax tree。Type checker 顾名思义会做一些类型检查，optimizer 会把 syntax tree/ast 转换成一些中间表示，coder generator 生成最终的可执行程序。</p>
<p><img src="/compiler1.png" alt=""><br>
这种自底向上的方式有什么问题呢？它需要将所有的源码都分析一遍，即使运行现在的程序只涉及部分代码。比如说下面这段代码，运行 main 函数并不需要 compiler 去分析函数 helper。</p>
<pre><code>fn helper() {
    ...
}

fn main() {
    print("hello world")
}
</code></pre>
<p>如果我们只想运行某一个函数，理想情况下，只需要编译该函数以及该函数调用的其他函数，传统的编译器没有办法做到这一点。</p>
<p>编译能自顶向下运行吗？<br>
<img src="/compiler2.png" alt=""><br>
要运行 main 函数 ->
需要知道 main 函数的 IR ->
需要对 main 函数做 type check ->
那得先 parse main 函数<br>
传统编译器的每个模块都是被动的，喂给我什么我就用什么。上图的编译器中每个模块都是主动的，自己需要什么就找其他模块要。</p>
<p>非常合理啊，唯一的问题是假设一个函数多次被调用，那每次都得重新编译一遍？第一反应是搞一个缓存，编译过的就不再编译了。远不止如此，这个过程还揭示了什么时候需要重新计算，比如说在原有代码中加了一行注释，type checker 在向下索要 syntax tree 的时候，发现其并没有改变， 所以 type check 不需要重新再做了，直接用上一次的结果就好，相应的，之后的编译的所有计算都不需要重新再做了。</p></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"01_plwm_note","contentHtml":"\u003cp\u003e本文是 nikomatsakis 在 \u003ca href=\"https://github.com/nikomatsakis/plmw-2022\"\u003ePLWM 2022\u003c/a\u003e 演讲的一点笔记。\u003c/p\u003e\n\u003cp\u003e传统编译器的工作模式是自底向上的。读取源代码，lexer 将源文本转换为一连串的 token，这些 token 输入给 parser ，parser 生成 syntax tree。Type checker 顾名思义会做一些类型检查，optimizer 会把 syntax tree/ast 转换成一些中间表示，coder generator 生成最终的可执行程序。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/compiler1.png\" alt=\"\"\u003e\u003cbr\u003e\n这种自底向上的方式有什么问题呢？它需要将所有的源码都分析一遍，即使运行现在的程序只涉及部分代码。比如说下面这段代码，运行 main 函数并不需要 compiler 去分析函数 helper。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efn helper() {\n    ...\n}\n\nfn main() {\n    print(\"hello world\")\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果我们只想运行某一个函数，理想情况下，只需要编译该函数以及该函数调用的其他函数，传统的编译器没有办法做到这一点。\u003c/p\u003e\n\u003cp\u003e编译能自顶向下运行吗？\u003cbr\u003e\n\u003cimg src=\"/compiler2.png\" alt=\"\"\u003e\u003cbr\u003e\n要运行 main 函数 -\u003e\n需要知道 main 函数的 IR -\u003e\n需要对 main 函数做 type check -\u003e\n那得先 parse main 函数\u003cbr\u003e\n传统编译器的每个模块都是被动的，喂给我什么我就用什么。上图的编译器中每个模块都是主动的，自己需要什么就找其他模块要。\u003c/p\u003e\n\u003cp\u003e非常合理啊，唯一的问题是假设一个函数多次被调用，那每次都得重新编译一遍？第一反应是搞一个缓存，编译过的就不再编译了。远不止如此，这个过程还揭示了什么时候需要重新计算，比如说在原有代码中加了一行注释，type checker 在向下索要 syntax tree 的时候，发现其并没有改变， 所以 type check 不需要重新再做了，直接用上一次的结果就好，相应的，之后的编译的所有计算都不需要重新再做了。\u003c/p\u003e","title":"自顶向下编译","date":"2022-02-21"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"01_plwm_note"},"buildId":"_qgOuqiGxjUsSi8y35n2B","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>