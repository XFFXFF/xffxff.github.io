<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>自顶向下编译</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/dba152634a942a1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dba152634a942a1a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/69a316e8a13b4830.css" as="style"/><link rel="stylesheet" href="/_next/static/css/69a316e8a13b4830.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-d719a31ca00eb19c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fcb060ba8fa2b368.js" defer=""></script><script src="/_next/static/chunks/640-1a3a0dc0790efd2e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-03d1a37039c741de.js" defer=""></script><script src="/_next/static/W-rlfqQsYX9oUEGVe_cQY/_buildManifest.js" defer=""></script><script src="/_next/static/W-rlfqQsYX9oUEGVe_cQY/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><main><article><h1 class="utils_headingXl__u25Y2">自顶向下编译</h1><div class="utils_lightText__eUzGY"><time dateTime="2022-02-21">February 21, 2022</time></div><div><p>本文是 nikomatsakis 在 <a href="https://github.com/nikomatsakis/plmw-2022">PLWM 2022</a> 演讲的一点笔记。</p>
<p>传统编译器的工作模式是自底向上的。读取源代码，lexer 将源文本转换为一连串的 token，这些 token 输入给 parser ，parser 生成 syntax tree。Type checker 顾名思义会做一些类型检查，optimizer 会把 syntax tree/ast 转换成一些中间表示，coder generator 生成最终的可执行程序。</p>
<p><img src="/compiler1.png" alt=""><br>
这种自底向上的方式有什么问题呢？它需要将所有的源码都分析一遍，即使运行现在的程序只涉及部分代码。比如说下面这段代码，运行main函数并不需要compiler去分析函数helper。</p>
<pre><code class="hljs language-php"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">helper</span>(<span class="hljs-params"></span>) </span>{
    ...
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">print</span>(<span class="hljs-string">"hello world"</span>)
}
</code></pre>
<p>如果我们只想运行某一个函数，理想情况下，只需要编译该函数以及该函数调用的其他函数，传统的编译器没有办法做到这一点。</p>
<p>编译能自顶向下运行吗？<br>
<img src="/compiler2.png" alt=""><br>
要运行 main 函数  ->
需要知道 main 函数的 IR ->
需要对 main 函数做 type check ->
那得先 parse main 函数传统编译器的每个模块都是被动的，喂给我什么我就用什么。上图的编译器中每个模块都是主动的，自己需要什么就找其他模块要。</p>
<p>非常合理啊，唯一的问题是假设一个函数多次被调用，那每次都得重新编译一遍？第一反应是搞一个缓存，编译过的就不再编译了。远不止如此，这个过程还揭示了什么时候需要重新计算，比如说在原有代码中加了一行注释，type checker 在向下索要 syntax tree 的时候，发现其并没有改变， 所以 type check 不需要重新再做了，直接用上一次的结果就好，相应的，之后的编译的所有计算都不需要重新再做了。</p></div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"01_plwm_note","contentHtml":"\u003cp\u003e本文是 nikomatsakis 在 \u003ca href=\"https://github.com/nikomatsakis/plmw-2022\"\u003ePLWM 2022\u003c/a\u003e 演讲的一点笔记。\u003c/p\u003e\n\u003cp\u003e传统编译器的工作模式是自底向上的。读取源代码，lexer 将源文本转换为一连串的 token，这些 token 输入给 parser ，parser 生成 syntax tree。Type checker 顾名思义会做一些类型检查，optimizer 会把 syntax tree/ast 转换成一些中间表示，coder generator 生成最终的可执行程序。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/compiler1.png\" alt=\"\"\u003e\u003cbr\u003e\n这种自底向上的方式有什么问题呢？它需要将所有的源码都分析一遍，即使运行现在的程序只涉及部分代码。比如说下面这段代码，运行main函数并不需要compiler去分析函数helper。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-php\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ehelper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    ...\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hello world\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果我们只想运行某一个函数，理想情况下，只需要编译该函数以及该函数调用的其他函数，传统的编译器没有办法做到这一点。\u003c/p\u003e\n\u003cp\u003e编译能自顶向下运行吗？\u003cbr\u003e\n\u003cimg src=\"/compiler2.png\" alt=\"\"\u003e\u003cbr\u003e\n要运行 main 函数  -\u003e\n需要知道 main 函数的 IR -\u003e\n需要对 main 函数做 type check -\u003e\n那得先 parse main 函数传统编译器的每个模块都是被动的，喂给我什么我就用什么。上图的编译器中每个模块都是主动的，自己需要什么就找其他模块要。\u003c/p\u003e\n\u003cp\u003e非常合理啊，唯一的问题是假设一个函数多次被调用，那每次都得重新编译一遍？第一反应是搞一个缓存，编译过的就不再编译了。远不止如此，这个过程还揭示了什么时候需要重新计算，比如说在原有代码中加了一行注释，type checker 在向下索要 syntax tree 的时候，发现其并没有改变， 所以 type check 不需要重新再做了，直接用上一次的结果就好，相应的，之后的编译的所有计算都不需要重新再做了。\u003c/p\u003e","title":"自顶向下编译","date":"2022-02-21"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"01_plwm_note"},"buildId":"W-rlfqQsYX9oUEGVe_cQY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>