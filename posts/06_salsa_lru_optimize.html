<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>Salsa: LRU needs keep dependency info</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/352a7f6477311b3a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/352a7f6477311b3a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4b57e02c440700a5.js" defer=""></script><script src="/_next/static/skgl9TzBTyGKcBdS-nOme/_buildManifest.js" defer=""></script><script src="/_next/static/skgl9TzBTyGKcBdS-nOme/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">Salsa: LRU needs keep dependency info</h1><div class="text-gray-500 mb-8 pb-2 border-b-2 border-solid border-slate-300"><time dateTime="2022-08-23">August 23, 2022</time></div><div><p>reivew <a href="https://github.com/salsa-rs/salsa/pull/371">#371</a> 加深了我对 salsa 做 recomputation 的理解。</p>
<p>我们先来看一个测试，思考这个测试能否 pass</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::tracked(jar = Jar, lru = 3)]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hot_potato</span>(db: &#x26;<span class="hljs-keyword">dyn</span> Db, input: MyInput) <span class="hljs-punctuation">-></span> Arc&#x3C;HotPotato> {
    db.<span class="hljs-title function_ invoke__">push_log</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">"get_hot_potato({:?})"</span>, input.<span class="hljs-title function_ invoke__">field</span>(db)));
    Arc::<span class="hljs-title function_ invoke__">new</span>(HotPotato::<span class="hljs-title function_ invoke__">new</span>(input.<span class="hljs-title function_ invoke__">field</span>(db)))
}

<span class="hljs-meta">#[salsa::tracked(jar = Jar)]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hot_potato2</span>(db: &#x26;<span class="hljs-keyword">dyn</span> Db, input: MyInput) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    db.<span class="hljs-title function_ invoke__">push_log</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">"get_hot_potato2({:?})"</span>, input.<span class="hljs-title function_ invoke__">field</span>(db)));
    <span class="hljs-title function_ invoke__">get_hot_potato</span>(db, input).<span class="hljs-number">0</span>
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">lru_keeps_dependency_info</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">db</span> = Database::<span class="hljs-title function_ invoke__">default</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">capacity</span> = <span class="hljs-number">3</span>;

    <span class="hljs-comment">// Invoke `get_hot_potato2` 33 times. This will (in turn) invoke</span>
    <span class="hljs-comment">// `get_hot_potato`, which will trigger LRU after 32 executions.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">inputs</span>: <span class="hljs-type">Vec</span>&#x3C;MyInput> = (<span class="hljs-number">0</span>..(capacity + <span class="hljs-number">1</span>))
        .<span class="hljs-title function_ invoke__">map</span>(|i| MyInput::<span class="hljs-title function_ invoke__">new</span>(&#x26;<span class="hljs-keyword">mut</span> db, i <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>))
        .<span class="hljs-title function_ invoke__">collect</span>();

    <span class="hljs-title function_ invoke__">for</span> (i, input) <span class="hljs-keyword">in</span> inputs.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">get_hot_potato2</span>(&#x26;db, *input);
        <span class="hljs-built_in">assert_eq!</span>(x <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, i);
    }

    db.<span class="hljs-title function_ invoke__">salsa_runtime_mut</span>()
        .<span class="hljs-title function_ invoke__">synthetic_write</span>(salsa::Durability::HIGH);

    <span class="hljs-comment">// We want to test that calls to `get_hot_potato2` are still considered</span>
    <span class="hljs-comment">// clean. Check that no new executions occur as we go here.</span>
    db.<span class="hljs-title function_ invoke__">assert_logs_len</span>((capacity + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);

    <span class="hljs-comment">// calling `get_hot_potato2(0)` has to check that `get_hot_potato(0)` is still valid;</span>
    <span class="hljs-comment">// even though we've evicted it (LRU), we find that it is still good</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-title function_ invoke__">get_hot_potato2</span>(&#x26;db, *inputs.<span class="hljs-title function_ invoke__">first</span>().<span class="hljs-title function_ invoke__">unwrap</span>());
    <span class="hljs-built_in">assert_eq!</span>(p, <span class="hljs-number">0</span>);
    db.<span class="hljs-title function_ invoke__">assert_logs_len</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p>这个测试是要做什么？</p>
<p>为了方便，将 <code>get_hot_potato</code> 记为 <code>get</code>，<code>get_hot_potato2</code> 记为 <code>get2</code>。</p>
<p>我们有两个 tracked function：<code>get</code> 和 <code>get2</code>，不用关心这两个 function 做了啥，只需要知道
<code>get2</code> 调用了 <code>get</code>，也就是说 <code>get2</code> 依赖 <code>get</code> 的结果。另一个需要注意的点是 <code>get</code> 设置了 <code>lru = 3</code>，而 <code>get2</code> 没有设置 lru。</p>
<p>现在调用 get2 四次，来看看 salsa 内部的状态，<code>get</code> 并没有存储 input 为 0 的结果，因为它设置了
<code>lru = 3</code>，input 为 0 的结果被 evict 了。</p>
<pre><code>+-------+----------------+-----------------+
| input |       get      |       get2      |
+-------+----------------+-----------------+
|   0   |                |        0        |
+-------+----------------+-----------------+
|   1   |        1       |        1        |
+-------+----------------+-----------------+
|   2   |        2       |        2        |
+-------+----------------+-----------------+
|   3   |        3       |        3        |
+-------+----------------+-----------------+
</code></pre>
<p>我们现在调用 <code>get2(0)</code>（这里应该写 <code>input0</code> 会比较好，<code>input0 = MyInput::new(&#x26;mut db, 0)</code>，但为了简单就写了 0），
能直接用 salsa 存储的结果吗？还需要重新计算吗？显然不用，不是存储有吗？那如果现在有别的输入改变了 salsa 的 <code>current_revision</code> 呢?
<code>synthetic_write</code> 就是在做这件事。也就是说 salsa 的 <code>current_revision</code> 大于 <code>get</code> 和 <code>get2</code> 结果被 verify
的 revision。这意味着 <a href="https://github.com/salsa-rs/salsa/blob/d3f0077d212d76ae81e6df0b7614ece9df469ed0/components/salsa-2022/src/function/maybe_changed_after.rs#L107-L135">shallow_verify_memo</a> 不能确定 <code>get2(0)</code> 的结果是否能用，得让 <a href="https://github.com/salsa-rs/salsa/blob/d3f0077d212d76ae81e6df0b7614ece9df469ed0/components/salsa-2022/src/function/maybe_changed_after.rs#L145-L202">deep_verify_memo</a>
去进一步判断。<code>deep_verify_memo</code> 会检查 <code>get2(0)</code> 依赖的其他计算结果有没有改变，所以会去查看 <code>get(0)</code>，
发现压根儿没有存储 <code>get(0)</code> 的结果，当然也没法判断它有没有改变，只能保守地认为发生了改变，所以 <code>get2(0)</code> 和
<code>get(0)</code> 都会重新计算。</p>
<p>显然，这不够好，实际上 <code>get2(0)</code> 的结果是可以重用的，因为 <code>get(0)</code> 的结果虽然被 evict 了，但并没有发生改变。
<strong>在我们这个场景下，<code>get2(0)</code> 并不关心 <code>get(0)</code> 的结果是多少，只关心从它上次被 verify 后有没有发生改变</strong>。</p>
<p>有没有方法去优化它呢？<a href="https://github.com/salsa-rs/salsa/pull/371">#371</a> 提供了一种解决方案。我们 evict 的时候，不再直接删除整个 <code>Memo</code>，只是把 <code>Memo.value</code> 设置为 <code>None</code>，保留
<code>verified_at</code> 和 <code>revisions</code>。</p>
<pre><code class="hljs language-rust"><span class="hljs-comment">/// Evicts the existing memo for the given key, replacing it</span>
<span class="hljs-comment">/// with an equivalent memo that has no value. If the memo is untracked, BaseInput, </span>
<span class="hljs-comment">/// or has values assigned as output of another query, this has no effect.</span>
<span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">super</span>) <span class="hljs-keyword">fn</span> <span class="hljs-title function_">evict</span>(&#x26;<span class="hljs-keyword">self</span>, key: K) {
    <span class="hljs-keyword">use</span> dashmap::mapref::entry::Entry::*;
    <span class="hljs-keyword">use</span> crate::runtime::local_state::QueryOrigin;

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Occupied</span>(entry )=  <span class="hljs-keyword">self</span>.map.<span class="hljs-title function_ invoke__">entry</span>(key) {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">memo</span> = entry.<span class="hljs-title function_ invoke__">get</span>().<span class="hljs-title function_ invoke__">load</span>();
        <span class="hljs-keyword">match</span> memo.revisions.origin {
            QueryOrigin::<span class="hljs-title function_ invoke__">Assigned</span>(_)
            | QueryOrigin::<span class="hljs-title function_ invoke__">DerivedUntracked</span>(_)
            | QueryOrigin::BaseInput
            | QueryOrigin::Field => {
                <span class="hljs-comment">// Careful: Cannot evict memos whose values were</span>
                <span class="hljs-comment">// assigned as output of another query</span>
                <span class="hljs-comment">// or those with untracked inputs</span>
                <span class="hljs-comment">// as their values cannot be reconstructed.</span>
                <span class="hljs-keyword">return</span>;
            },
            
            QueryOrigin::<span class="hljs-title function_ invoke__">Derived</span>(_) => {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">memo_evicted</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Memo::<span class="hljs-title function_ invoke__">new</span>(
                    None::&#x3C;V>,
                    memo.verified_at.<span class="hljs-title function_ invoke__">load</span>(),
                    memo.revisions.<span class="hljs-title function_ invoke__">clone</span>(),
                ));

                entry.<span class="hljs-title function_ invoke__">get</span>().<span class="hljs-title function_ invoke__">store</span>(memo_evicted);
            }
        }
    }
}
</code></pre></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"06_salsa_lru_optimize","contentHtml":"\u003cp\u003ereivew \u003ca href=\"https://github.com/salsa-rs/salsa/pull/371\"\u003e#371\u003c/a\u003e 加深了我对 salsa 做 recomputation 的理解。\u003c/p\u003e\n\u003cp\u003e我们先来看一个测试，思考这个测试能否 pass\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked(jar = Jar, lru = 3)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_hot_potato\u003c/span\u003e(db: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003edyn\u003c/span\u003e Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Arc\u0026#x3C;HotPotato\u003e {\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush_log\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eformat!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"get_hot_potato({:?})\"\u003c/span\u003e, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db)));\n    Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(HotPotato::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db)))\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked(jar = Jar)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_hot_potato2\u003c/span\u003e(db: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003edyn\u003c/span\u003e Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush_log\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eformat!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"get_hot_potato2({:?})\"\u003c/span\u003e, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db)));\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eget_hot_potato\u003c/span\u003e(db, input).\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[test]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elru_keeps_dependency_info\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003edb\u003c/span\u003e = Database::\u003cspan class=\"hljs-title function_ invoke__\"\u003edefault\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecapacity\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Invoke `get_hot_potato2` 33 times. This will (in turn) invoke\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// `get_hot_potato`, which will trigger LRU after 32 executions.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003einputs\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;MyInput\u003e = (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..(capacity + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003emap\u003c/span\u003e(|i| MyInput::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e db, i \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e))\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003ecollect\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (i, input) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e inputs.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eenumerate\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eget_hot_potato2\u003c/span\u003e(\u0026#x26;db, *input);\n        \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(x \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e, i);\n    }\n\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003esalsa_runtime_mut\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_ invoke__\"\u003esynthetic_write\u003c/span\u003e(salsa::Durability::HIGH);\n\n    \u003cspan class=\"hljs-comment\"\u003e// We want to test that calls to `get_hot_potato2` are still considered\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// clean. Check that no new executions occur as we go here.\u003c/span\u003e\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003eassert_logs_len\u003c/span\u003e((capacity + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// calling `get_hot_potato2(0)` has to check that `get_hot_potato(0)` is still valid;\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// even though we've evicted it (LRU), we find that it is still good\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ep\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eget_hot_potato2\u003c/span\u003e(\u0026#x26;db, *inputs.\u003cspan class=\"hljs-title function_ invoke__\"\u003efirst\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e());\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(p, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003eassert_logs_len\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个测试是要做什么？\u003c/p\u003e\n\u003cp\u003e为了方便，将 \u003ccode\u003eget_hot_potato\u003c/code\u003e 记为 \u003ccode\u003eget\u003c/code\u003e，\u003ccode\u003eget_hot_potato2\u003c/code\u003e 记为 \u003ccode\u003eget2\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e我们有两个 tracked function：\u003ccode\u003eget\u003c/code\u003e 和 \u003ccode\u003eget2\u003c/code\u003e，不用关心这两个 function 做了啥，只需要知道\n\u003ccode\u003eget2\u003c/code\u003e 调用了 \u003ccode\u003eget\u003c/code\u003e，也就是说 \u003ccode\u003eget2\u003c/code\u003e 依赖 \u003ccode\u003eget\u003c/code\u003e 的结果。另一个需要注意的点是 \u003ccode\u003eget\u003c/code\u003e 设置了 \u003ccode\u003elru = 3\u003c/code\u003e，而 \u003ccode\u003eget2\u003c/code\u003e 没有设置 lru。\u003c/p\u003e\n\u003cp\u003e现在调用 get2 四次，来看看 salsa 内部的状态，\u003ccode\u003eget\u003c/code\u003e 并没有存储 input 为 0 的结果，因为它设置了\n\u003ccode\u003elru = 3\u003c/code\u003e，input 为 0 的结果被 evict 了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e+-------+----------------+-----------------+\n| input |       get      |       get2      |\n+-------+----------------+-----------------+\n|   0   |                |        0        |\n+-------+----------------+-----------------+\n|   1   |        1       |        1        |\n+-------+----------------+-----------------+\n|   2   |        2       |        2        |\n+-------+----------------+-----------------+\n|   3   |        3       |        3        |\n+-------+----------------+-----------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们现在调用 \u003ccode\u003eget2(0)\u003c/code\u003e（这里应该写 \u003ccode\u003einput0\u003c/code\u003e 会比较好，\u003ccode\u003einput0 = MyInput::new(\u0026#x26;mut db, 0)\u003c/code\u003e，但为了简单就写了 0），\n能直接用 salsa 存储的结果吗？还需要重新计算吗？显然不用，不是存储有吗？那如果现在有别的输入改变了 salsa 的 \u003ccode\u003ecurrent_revision\u003c/code\u003e 呢?\n\u003ccode\u003esynthetic_write\u003c/code\u003e 就是在做这件事。也就是说 salsa 的 \u003ccode\u003ecurrent_revision\u003c/code\u003e 大于 \u003ccode\u003eget\u003c/code\u003e 和 \u003ccode\u003eget2\u003c/code\u003e 结果被 verify\n的 revision。这意味着 \u003ca href=\"https://github.com/salsa-rs/salsa/blob/d3f0077d212d76ae81e6df0b7614ece9df469ed0/components/salsa-2022/src/function/maybe_changed_after.rs#L107-L135\"\u003eshallow_verify_memo\u003c/a\u003e 不能确定 \u003ccode\u003eget2(0)\u003c/code\u003e 的结果是否能用，得让 \u003ca href=\"https://github.com/salsa-rs/salsa/blob/d3f0077d212d76ae81e6df0b7614ece9df469ed0/components/salsa-2022/src/function/maybe_changed_after.rs#L145-L202\"\u003edeep_verify_memo\u003c/a\u003e\n去进一步判断。\u003ccode\u003edeep_verify_memo\u003c/code\u003e 会检查 \u003ccode\u003eget2(0)\u003c/code\u003e 依赖的其他计算结果有没有改变，所以会去查看 \u003ccode\u003eget(0)\u003c/code\u003e，\n发现压根儿没有存储 \u003ccode\u003eget(0)\u003c/code\u003e 的结果，当然也没法判断它有没有改变，只能保守地认为发生了改变，所以 \u003ccode\u003eget2(0)\u003c/code\u003e 和\n\u003ccode\u003eget(0)\u003c/code\u003e 都会重新计算。\u003c/p\u003e\n\u003cp\u003e显然，这不够好，实际上 \u003ccode\u003eget2(0)\u003c/code\u003e 的结果是可以重用的，因为 \u003ccode\u003eget(0)\u003c/code\u003e 的结果虽然被 evict 了，但并没有发生改变。\n\u003cstrong\u003e在我们这个场景下，\u003ccode\u003eget2(0)\u003c/code\u003e 并不关心 \u003ccode\u003eget(0)\u003c/code\u003e 的结果是多少，只关心从它上次被 verify 后有没有发生改变\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e有没有方法去优化它呢？\u003ca href=\"https://github.com/salsa-rs/salsa/pull/371\"\u003e#371\u003c/a\u003e 提供了一种解决方案。我们 evict 的时候，不再直接删除整个 \u003ccode\u003eMemo\u003c/code\u003e，只是把 \u003ccode\u003eMemo.value\u003c/code\u003e 设置为 \u003ccode\u003eNone\u003c/code\u003e，保留\n\u003ccode\u003everified_at\u003c/code\u003e 和 \u003ccode\u003erevisions\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e/// Evicts the existing memo for the given key, replacing it\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// with an equivalent memo that has no value. If the memo is untracked, BaseInput, \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// or has values assigned as output of another query, this has no effect.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_ invoke__\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eevict\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, key: K) {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e dashmap::mapref::entry::Entry::*;\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e crate::runtime::local_state::QueryOrigin;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eOccupied\u003c/span\u003e(entry )=  \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.map.\u003cspan class=\"hljs-title function_ invoke__\"\u003eentry\u003c/span\u003e(key) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ememo\u003c/span\u003e = entry.\u003cspan class=\"hljs-title function_ invoke__\"\u003eget\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eload\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e memo.revisions.origin {\n            QueryOrigin::\u003cspan class=\"hljs-title function_ invoke__\"\u003eAssigned\u003c/span\u003e(_)\n            | QueryOrigin::\u003cspan class=\"hljs-title function_ invoke__\"\u003eDerivedUntracked\u003c/span\u003e(_)\n            | QueryOrigin::BaseInput\n            | QueryOrigin::Field =\u003e {\n                \u003cspan class=\"hljs-comment\"\u003e// Careful: Cannot evict memos whose values were\u003c/span\u003e\n                \u003cspan class=\"hljs-comment\"\u003e// assigned as output of another query\u003c/span\u003e\n                \u003cspan class=\"hljs-comment\"\u003e// or those with untracked inputs\u003c/span\u003e\n                \u003cspan class=\"hljs-comment\"\u003e// as their values cannot be reconstructed.\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n            },\n            \n            QueryOrigin::\u003cspan class=\"hljs-title function_ invoke__\"\u003eDerived\u003c/span\u003e(_) =\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ememo_evicted\u003c/span\u003e = Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(Memo::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\n                    None::\u0026#x3C;V\u003e,\n                    memo.verified_at.\u003cspan class=\"hljs-title function_ invoke__\"\u003eload\u003c/span\u003e(),\n                    memo.revisions.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(),\n                ));\n\n                entry.\u003cspan class=\"hljs-title function_ invoke__\"\u003eget\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003estore\u003c/span\u003e(memo_evicted);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e","title":"Salsa: LRU needs keep dependency info","date":"2022-08-23"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"06_salsa_lru_optimize"},"buildId":"skgl9TzBTyGKcBdS-nOme","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>