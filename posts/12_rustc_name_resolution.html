<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>rustc 如何做 name resolution</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/9df99577566bdedd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9df99577566bdedd.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-6cbe6e332df95288.js" defer=""></script><script src="/_next/static/chunks/main-26f9f36b33181737.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d6bf7b3192a8752.js" defer=""></script><script src="/_next/static/chunks/73-96e6cbd54826b874.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-3713afaca23057c0.js" defer=""></script><script src="/_next/static/E2PQOX0jfmscotOLq-Drj/_buildManifest.js" defer=""></script><script src="/_next/static/E2PQOX0jfmscotOLq-Drj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="max-w-4xl px-4 mt-12 mb-24 mx-auto"><main><article><h1 class="text-3xl font-medium my-4 border-b-0">rustc 如何做 name resolution</h1><div class="text-gray-500 mb-1"><time dateTime="2021-11-06">November 6, 2021</time></div><div><p>先吐槽一下，原本前两天 <a href="https://rust-lang.github.io/rustc-reading-club/meetings/2021-11-04.html">rustc reading
club</a>
有个关于 name resolution 源码阅读的直播，但直播时发现 zoom 最多只能容纳 100 人，主讲人进不来了。他们也没有想到会有这么多人，最终是取消了这次活动。</p>
<p>虽然活动没了，但 rustc 还是要学的。这不是一篇源码阅读，全文不涉及任何  rustc 的代码，因为我压根儿没怎么看
<a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_resolve/src">rustc_resolve</a>
的代码，倒是看了一些 rust-analyzer 中 name resolution 的代码。这几天看 rust 开发文档，RFC 以及 rust-analyzer，本文是对 name resolution 的一个总结。</p>
<h2>什么是 name resolution?</h2>
<p>在编译时，将 name 和 definition 匹配的过程。比如说下面这个例子，我们在 bar 这个函数中使用 foo 的时候 ，需要知道 foo 指代的是第一行 foo 函数。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() { ... }

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() { <span class="hljs-title function_ invoke__">foo</span>(); }
</code></pre>
<h2>Namespace</h2>
<p>怎么实现 name resolution 呢？能否定义一个 map，key 是 name，value 是 definition
呢？现在的一个关键点是在同一 scope 下，name 是唯一的吗？很遗憾，在 rust 中，并不是</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() { ... }

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">foo</span> { field: <span class="hljs-type">u32</span> }
</code></pre>
<p>上述代码是合法的，可以同时有一个叫 foo 的函数，还有一个叫 foo 的 struct。函数foo
和 struct foo 并不在同一 namespace 下，函数 foo 属于 value namespace，而struct
foo 属于 type namespace。除了 type 和 value namespace 之外，还有macro、lifetime
以及 label namespace， 如果想知道不同 namespace 下有哪些东西，可以参考 <a href="https://doc.rust-lang.org/nightly/reference/names/namespaces.html">rust
reference
namespace</a></p>
<h2>Import</h2>
<p>考虑 import 的话，会让问题变得复杂起来。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">mod</span> a {
    <span class="hljs-keyword">use</span> crate::b::foo;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() {}
}

<span class="hljs-keyword">mod</span> b {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() {}
}
</code></pre>
<p>假设编译器从上往下开始 resolve，很快就会发现，mod a 中 import 了 mod b 中的东西，但是现在 mod b 还没有被 resolve，不知道 mod b 中定义了哪些东西，有没有定义
foo。第一反应是，当编译器 resolve 这个 import 的时候，先去把 mod b 给 resolve
了，完事儿后在跑回来 resolve 这个 import 的。听起来很合理，但考虑下面这个情形呢？</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">mod</span> a {
    <span class="hljs-keyword">use</span> crate::b::foo;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() {}
}

<span class="hljs-keyword">mod</span> b {
    <span class="hljs-keyword">use</span> crate::a::bar;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() {}
}
</code></pre>
<p>在 mod a 中 import mod b，mod b 中又 import 了 mod a。编译器 name resolution 的过程是 a-->b-->a-->b-->......，会进入一个死循环。</p>
<p>怎么解决这个问题呢？碰到 import，可以先跳过。第一遍尽可能的去 resolve，如果
import 无法 resolve，就把它放到一个 working list 中。然后遍历 working list，尝试去 resolve 它们，如果 resolve 完成，就把它踢出 working list。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">mod</span> a {
    <span class="hljs-keyword">use</span> crate::b::bar;
}

<span class="hljs-keyword">mod</span> b {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::c::bar;
}

<span class="hljs-keyword">mod</span> c {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() {}
}
</code></pre>
<p>working list 可能要遍历多次，考虑上面这个例子，第一轮 resolve 后，会得到一个包含
<code>use crate::b::bar</code>, <code>use crate::c::bar</code> 的 working list，遍历 working list，先去resolve <code>use crate::b::bar</code>，但 resolve 它依赖 <code>use crate::c::bar</code> 先
resolve。所以第一次遍历 working list 后还会剩下 <code>use crate::b::bar</code>，再遍历一次才能完成所有的name resolution。当然，也有可能 working list 无法清空，比如 mod c
中并没有定义bar 函数。这个方法的核心思想就是不断遍历 working list，直到 working
list 的长度不变，如果 working list 为空，那就说明 name resolution 成功，反之则说明代码有问题。</p>
<h2>Macro</h2>
<pre><code class="hljs language-rust"><span class="hljs-built_in">macro_rules!</span> strukt {
    ($i:ident) => {
        <span class="hljs-keyword">struct</span> $i { field: <span class="hljs-type">u32</span> }
    }
}
strukt!(Foo);
strukts!(Foo) 做 <span class="hljs-keyword">macro</span> expansion 会定义一个叫 Foo 的 <span class="hljs-keyword">struct</span>

<span class="hljs-title class_">struct</span> Foo {
    field: <span class="hljs-type">u32</span>
}
</code></pre>
<p>在生成 AST 的时候并没有做 macro expansion，在 rust-analyzer 中，<code>strukt!(Foo)</code>
对应的 node 如下</p>
<pre><code>  MACRO_CALL@176..189
    PATH@176..182
      PATH_SEGMENT@176..182
        NAME_REF@176..182
          IDENT@176..182 "strukt"
    BANG@182..183 "!"
    TOKEN_TREE@183..188
      L_PAREN@183..184 "("
      IDENT@184..187 "Foo"
      R_PAREN@187..188 ")"
    SEMICOLON@188..189 ";" 
</code></pre>
<p>macro expansion 发生在 name resolution 中，处理的方式和 import 类似，遇到还不能
resolve 的 macro，就先把它放到 working list 中。比如说 macro 是 import 来的，或者这个 macro 依赖于另一个 macro，下面这个例子中，<code>strukt!(Foo)</code> 完全 exapnd 之前，<code>field_type!()</code> 得先 expand。</p>
<pre><code class="hljs language-rust"><span class="hljs-built_in">macro_rules!</span> field_type {
    () => {
        <span class="hljs-type">u64</span>
    };
}

<span class="hljs-built_in">macro_rules!</span> strukt {
    ($i:ident) => {
        <span class="hljs-keyword">struct</span> $i {
            field: field_type!(),
        }
    };
}

strukt!(Foo);
</code></pre>
<p>rust 中的 name resolution 还有很多细节我没有讨论，其实我也不清楚，但大多对我来说也算 corner case，现在也不想了解。</p>
<h2>参考资料</h2>
<p><a href="https://rustc-dev-guide.rust-lang.org/name-resolution.html#name-resolution">rustc dev guide: name resolution</a></p>
<p><a href="https://rust-lang.github.io/rfcs/1560-name-resolution.html">RFC 1560: name resolution</a></p>
<p><a href="https://doc.rust-lang.org/stable/reference/names/namespaces.html">rust reference: namespace</a></p>
<p><a href="https://willcrichton.net/notes/specificity-programming-languages/">"Do What I Mean": Name Resolution in Programming Languages</a></p></div></article></main><div class="mt-12"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"12_rustc_name_resolution","contentHtml":"\u003cp\u003e先吐槽一下，原本前两天 \u003ca href=\"https://rust-lang.github.io/rustc-reading-club/meetings/2021-11-04.html\"\u003erustc reading\nclub\u003c/a\u003e\n有个关于 name resolution 源码阅读的直播，但直播时发现 zoom 最多只能容纳 100 人，主讲人进不来了。他们也没有想到会有这么多人，最终是取消了这次活动。\u003c/p\u003e\n\u003cp\u003e虽然活动没了，但 rustc 还是要学的。这不是一篇源码阅读，全文不涉及任何  rustc 的代码，因为我压根儿没怎么看\n\u003ca href=\"https://github.com/rust-lang/rust/tree/master/compiler/rustc_resolve/src\"\u003erustc_resolve\u003c/a\u003e\n的代码，倒是看了一些 rust-analyzer 中 name resolution 的代码。这几天看 rust 开发文档，RFC 以及 rust-analyzer，本文是对 name resolution 的一个总结。\u003c/p\u003e\n\u003ch2\u003e什么是 name resolution?\u003c/h2\u003e\n\u003cp\u003e在编译时，将 name 和 definition 匹配的过程。比如说下面这个例子，我们在 bar 这个函数中使用 foo 的时候 ，需要知道 foo 指代的是第一行 foo 函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e() { ... }\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e() { \u003cspan class=\"hljs-title function_ invoke__\"\u003efoo\u003c/span\u003e(); }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eNamespace\u003c/h2\u003e\n\u003cp\u003e怎么实现 name resolution 呢？能否定义一个 map，key 是 name，value 是 definition\n呢？现在的一个关键点是在同一 scope 下，name 是唯一的吗？很遗憾，在 rust 中，并不是\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e() { ... }\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003efoo\u003c/span\u003e { field: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码是合法的，可以同时有一个叫 foo 的函数，还有一个叫 foo 的 struct。函数foo\n和 struct foo 并不在同一 namespace 下，函数 foo 属于 value namespace，而struct\nfoo 属于 type namespace。除了 type 和 value namespace 之外，还有macro、lifetime\n以及 label namespace， 如果想知道不同 namespace 下有哪些东西，可以参考 \u003ca href=\"https://doc.rust-lang.org/nightly/reference/names/namespaces.html\"\u003erust\nreference\nnamespace\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eImport\u003c/h2\u003e\n\u003cp\u003e考虑 import 的话，会让问题变得复杂起来。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e a {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e crate::b::foo;\n\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e() {}\n}\n\n\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e b {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e() {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e假设编译器从上往下开始 resolve，很快就会发现，mod a 中 import 了 mod b 中的东西，但是现在 mod b 还没有被 resolve，不知道 mod b 中定义了哪些东西，有没有定义\nfoo。第一反应是，当编译器 resolve 这个 import 的时候，先去把 mod b 给 resolve\n了，完事儿后在跑回来 resolve 这个 import 的。听起来很合理，但考虑下面这个情形呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e a {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e crate::b::foo;\n\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e() {}\n}\n\n\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e b {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e crate::a::bar;\n\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e() {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 mod a 中 import mod b，mod b 中又 import 了 mod a。编译器 name resolution 的过程是 a--\u003eb--\u003ea--\u003eb--\u003e......，会进入一个死循环。\u003c/p\u003e\n\u003cp\u003e怎么解决这个问题呢？碰到 import，可以先跳过。第一遍尽可能的去 resolve，如果\nimport 无法 resolve，就把它放到一个 working list 中。然后遍历 working list，尝试去 resolve 它们，如果 resolve 完成，就把它踢出 working list。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e a {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e crate::b::bar;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e b {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e crate::c::bar;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e c {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e() {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eworking list 可能要遍历多次，考虑上面这个例子，第一轮 resolve 后，会得到一个包含\n\u003ccode\u003euse crate::b::bar\u003c/code\u003e, \u003ccode\u003euse crate::c::bar\u003c/code\u003e 的 working list，遍历 working list，先去resolve \u003ccode\u003euse crate::b::bar\u003c/code\u003e，但 resolve 它依赖 \u003ccode\u003euse crate::c::bar\u003c/code\u003e 先\nresolve。所以第一次遍历 working list 后还会剩下 \u003ccode\u003euse crate::b::bar\u003c/code\u003e，再遍历一次才能完成所有的name resolution。当然，也有可能 working list 无法清空，比如 mod c\n中并没有定义bar 函数。这个方法的核心思想就是不断遍历 working list，直到 working\nlist 的长度不变，如果 working list 为空，那就说明 name resolution 成功，反之则说明代码有问题。\u003c/p\u003e\n\u003ch2\u003eMacro\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-built_in\"\u003emacro_rules!\u003c/span\u003e strukt {\n    ($i:ident) =\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e $i { field: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e }\n    }\n}\nstrukt!(Foo);\nstrukts!(Foo) 做 \u003cspan class=\"hljs-keyword\"\u003emacro\u003c/span\u003e expansion 会定义一个叫 Foo 的 \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003estruct\u003c/span\u003e Foo {\n    field: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在生成 AST 的时候并没有做 macro expansion，在 rust-analyzer 中，\u003ccode\u003estrukt!(Foo)\u003c/code\u003e\n对应的 node 如下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  MACRO_CALL@176..189\n    PATH@176..182\n      PATH_SEGMENT@176..182\n        NAME_REF@176..182\n          IDENT@176..182 \"strukt\"\n    BANG@182..183 \"!\"\n    TOKEN_TREE@183..188\n      L_PAREN@183..184 \"(\"\n      IDENT@184..187 \"Foo\"\n      R_PAREN@187..188 \")\"\n    SEMICOLON@188..189 \";\" \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emacro expansion 发生在 name resolution 中，处理的方式和 import 类似，遇到还不能\nresolve 的 macro，就先把它放到 working list 中。比如说 macro 是 import 来的，或者这个 macro 依赖于另一个 macro，下面这个例子中，\u003ccode\u003estrukt!(Foo)\u003c/code\u003e 完全 exapnd 之前，\u003ccode\u003efield_type!()\u003c/code\u003e 得先 expand。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-built_in\"\u003emacro_rules!\u003c/span\u003e field_type {\n    () =\u003e {\n        \u003cspan class=\"hljs-type\"\u003eu64\u003c/span\u003e\n    };\n}\n\n\u003cspan class=\"hljs-built_in\"\u003emacro_rules!\u003c/span\u003e strukt {\n    ($i:ident) =\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e $i {\n            field: field_type!(),\n        }\n    };\n}\n\nstrukt!(Foo);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erust 中的 name resolution 还有很多细节我没有讨论，其实我也不清楚，但大多对我来说也算 corner case，现在也不想了解。\u003c/p\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://rustc-dev-guide.rust-lang.org/name-resolution.html#name-resolution\"\u003erustc dev guide: name resolution\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://rust-lang.github.io/rfcs/1560-name-resolution.html\"\u003eRFC 1560: name resolution\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/stable/reference/names/namespaces.html\"\u003erust reference: namespace\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://willcrichton.net/notes/specificity-programming-languages/\"\u003e\"Do What I Mean\": Name Resolution in Programming Languages\u003c/a\u003e\u003c/p\u003e","title":"rustc 如何做 name resolution","date":"2021-11-06"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"12_rustc_name_resolution"},"buildId":"E2PQOX0jfmscotOLq-Drj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>