<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>WIP: Salsa: Is the tracked struct valid?</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/dba152634a942a1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dba152634a942a1a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/69a316e8a13b4830.css" as="style"/><link rel="stylesheet" href="/_next/static/css/69a316e8a13b4830.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-d719a31ca00eb19c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fcb060ba8fa2b368.js" defer=""></script><script src="/_next/static/chunks/640-1a3a0dc0790efd2e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-03d1a37039c741de.js" defer=""></script><script src="/_next/static/ZhnmZdMHvYJ54x3heEJPU/_buildManifest.js" defer=""></script><script src="/_next/static/ZhnmZdMHvYJ54x3heEJPU/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><main><article><h1 class="utils_headingXl__u25Y2">WIP: Salsa: Is the tracked struct valid?</h1><div class="utils_lightText__eUzGY"><time dateTime="2022-09-26">September 26, 2022</time></div><div><p>来来回回讨论了两周，终于把这个 <a href="https://github.com/salsa-rs/salsa/pull/413">PR</a>
合进去了，这是我参与开源项目以来，第一次讨论这么多。通过这个 PR，有很多思考，对Salsa 也有了更深入的理解，值得把它们记录下来</p>
<p>Issue: <a href="https://github.com/salsa-rs/salsa/issues/407">https://github.com/salsa-rs/salsa/issues/407</a></p>
<p>PR: <a href="https://github.com/salsa-rs/salsa/pull/413">https://github.com/salsa-rs/salsa/pull/413</a></p>
<h2>问题</h2>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> MyTracked {
    MyTracked::<span class="hljs-title function_ invoke__">new</span>(db, input.<span class="hljs-title function_ invoke__">field</span>(db) * <span class="hljs-number">2</span>)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    ...
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input</span> = MyInput::<span class="hljs-title function_ invoke__">new</span>(&#x26;db, <span class="hljs-number">11</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">tracked</span> = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input);

    input.<span class="hljs-title function_ invoke__">set_field</span>(&#x26;<span class="hljs-keyword">mut</span> db).<span class="hljs-title function_ invoke__">to</span>(<span class="hljs-number">12</span>);
    dbg!(tracked.<span class="hljs-title function_ invoke__">field</span>(&#x26;db));
}
</code></pre>
<p>修改 <code>input</code> 后，<code>tracked</code> 还有效吗？对于上面这段代码，Salsa 希望在调用
<code>tracked.field(&#x26;db)</code> 时 panic。而我们现在的代码，也就是这个 PR 之前，并不会
panic，会返回上次保存的值 22。</p>
<h2>Inputs and Outputs</h2>
<p>在深入讨论这个问题之前，有必要介绍一下 inputs 和 outputs 这两个概念。</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> 这里的inputs 和 outputs 都是 salsa 内部实现的概念，不是用户接口
<a href="https://salsa-rs.netlify.app/overview.html#inputs">input</a></p>
</blockquote>
<p>Inputs 就是我们在<a href="./07_salsa_dependency.md">这篇文章</a>中讨论的 dependencies。一个
query 的 inputs 即这个 query 依赖的其他 query。</p>
<p>以下三种东西会视为 query 的 outputs</p>
<ul>
<li>生成的 <a href="https://salsa-rs.netlify.app/overview.html#tracked-structs">tracked struct</a></li>
<li>调用 <a href="https://salsa-rs.netlify.app/overview.html#specify-the-result-of-tracked-functions-for-particular-structs">specify</a></li>
<li>push 到 <a href="https://salsa-rs.netlify.app/overview.html#accumulators">accumulator</a> 的值</li>
</ul>
<p>Inputs 和 outputs 这两个东西有什么用？Salsa 的核心是尽可能利用之前的计算结果来加快当前的计算，inputs 用来判断之前的计算结果现在仍否可用，outputs 对更多地利用之前的计算结果有帮助。</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> MyTracked {
    MyTracked::<span class="hljs-title function_ invoke__">new</span>(db, input.<span class="hljs-title function_ invoke__">field</span>(db) * <span class="hljs-number">2</span>)
}
</code></pre>
<p>对于 query <code>tracked_fn(db, input)</code> 来说</p>
<ul>
<li>inputs: <code>input.field(db)</code></li>
<li>outputs: <code>MyTracked::new(db, input.field(db) * 2)</code></li>
</ul>
<p>如果我们发现数据库中存储有 query <code>tracked_fn(db, input)</code> 的值，我们能直接用这个结果吗？换句话说，我们需要重新计算吗？如果这个结果没有在最新的 <a href="https://salsa-rs.netlify.app/plumbing/terminology/revision.html?highlight=revision#revision">revision</a> 下被验证，我们就需要检查这个 query 的 inputs，如果所有的 inputs 在上次计算后都没有改变，就可以下结论之前存储的计算结果仍然是有效的。与此同时，我们还可以认为这个
query 的 outputs 在最新的 <a href="https://salsa-rs.netlify.app/plumbing/terminology/revision.html?highlight=revision#revision">revision</a> 下得到了验证，因为 Salsa 的一个基本假设就是所有的计算都是确定性的，inputs 不变，outputs 就应该不变。</p>
<h2>Panic if outdated</h2>
<p>现在再次回到最开始的问题，对于 tracked struct 的 fields，一旦发现它过时了，就应该 panic。怎么判断它是否过时了呢？如果保存的旧值的 <code>verified_at</code> 小于系统的
<code>current_revision</code>，我们就说这个值过时了（我们这里对“过时”的讨论是针对 tracked
struct 的）。看看我们上面这个例子，改变 input 的时候，<code>current_revision</code> 就会
+1，大于 <code>tracked.field(&#x26;db)</code> 查询到的值的<code>verified_at</code>，所以应该
panic。（reference:
<a href="https://github.com/salsa-rs/salsa/issues/407#issuecomment-1244550905%EF%BC%89">https://github.com/salsa-rs/salsa/issues/407#issuecomment-1244550905）</a></p>
<p>看起来合理，但这样改之后，之前的测试有的通不过了。</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">tracked</span> = MyTracked::<span class="hljs-title function_ invoke__">new</span>(db, input.<span class="hljs-title function_ invoke__">field</span>(db) * <span class="hljs-number">2</span>);
    tracked.<span class="hljs-title function_ invoke__">field</span>(db)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    ...
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input</span> = MyInput::<span class="hljs-title function_ invoke__">new</span>(&#x26;db, <span class="hljs-number">11</span>);
    _ = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input);

    <span class="hljs-comment">// A "synthetic write" causes the system to act *as though* some</span>
    <span class="hljs-comment">// input of durability `durability` has changed. This is mostly</span>
    <span class="hljs-comment">// useful for profiling scenarios.</span>
    db.<span class="hljs-title function_ invoke__">synthetic_write</span>(salsa::Durabiliby::High);
    _ = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input); <span class="hljs-comment">// panic</span>
}
</code></pre>
<p>第二次调用 <code>tracked_fn</code> 会 panic，这里真的应该 panic 吗？对于整个系统来说，我们更改了部分输入，但并没有更改这里的 <code>input</code>，所以保存的 <code>tracked_fn(&#x26;db, input)</code>
旧值仍然是有效的，这种情况正是我们希望 Salsa 帮我们节省的计算。</p>
<p>这个例子的特殊之处在 <code>tracked</code>（准确来说应该是 <code>tracked.field</code>） 既是
<code>tracked_fn(&#x26;db, input)</code> 的 input，又是它的output。</p>
<p>第二次调用 <code>tracked_fn(&#x26;db, input)</code>，发现 db 中保存有之前的计算结果，但它可能是过时的，因为它对应的 <code>verified_at</code> 小于 <code>current_revision</code> （这里讨论的是tracked
function，所以并不一定是过时的，和上面讨论的 tracked struct 不一样）。这时，我们需要 <a href="https://github.com/salsa-rs/salsa/blob/2ffe4a78a824acb8c73e77497e4c2c469fcbed37/components/salsa-2022/src/function/maybe_changed_after.rs#L145">deep verify</a>，检查这个 query 的所有 inputs 在其 <code>verified_at</code> 之后有没有改变。<code>tracked.field(db)</code> 就是它的一个 input，显然它的 <code>verified_at</code> 小于
<code>current_revision</code>，前面已经提到</p>
<blockquote>
<p>对于 tracked struct 的 fields，一旦发现它 outdated，就应该 panic。如果保存的旧
值的 <code>verified_at</code> 小于 <code>current_revision</code>，我们就说这个旧值outdated。</p>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> MyTracked {
    MyTracked::<span class="hljs-title function_ invoke__">new</span>(db, input.<span class="hljs-title function_ invoke__">field</span>(db) * <span class="hljs-number">2</span>)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    ...
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input</span> = MyInput::<span class="hljs-title function_ invoke__">new</span>(&#x26;db, <span class="hljs-number">11</span>);
    _ = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input);

    db.<span class="hljs-title function_ invoke__">synthetic_write</span>(salsa::Durabiliby::High);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">tracked</span> = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input);
    dbg!(tracked.<span class="hljs-title function_ invoke__">field</span>(&#x26;db));
}
</code></pre>
<p>如果改写成上面这样，就可以正常工作了。第二次调用 <code>tracked_fn(&#x26;db, input)</code> 发现保存的旧值是有效的，不用重新计算。在验证完这个 query 之后，我们认为这个它的所有
outputs 也在<code>current_revision</code> 下得到了验证，也是有效的，即更新 outputs 的
<code>verified_at</code> 为<code>current_revision</code>。所以接下来调用 <code>tracked.field(&#x26;db)</code> 时，它的
<code>verified_at</code> 等于 <code>current_revision</code>，这个 field 的旧值也是有效的。</p>
<p>如果一个 tracked struct 既是一个 query 的 input，又是其 output，在验证这个 query
的<strong>过程中</strong>，我们还没来得及更新 outputs 的 <code>verified_at</code>（<strong>必须在验证结束后才能更新其 outputs</strong>)，就要将它作为input使用，这时它的 <code>verified_at</code> 小于
<code>current_revision</code>，所以会 panic。</p>
<h2>Is it really outdated?</h2>
<p>上一节中 <code>tracked.field(db)</code> 其实是可用的，我们单纯用它的 <code>verified_at</code> 做比较是有漏洞的。这个场景的特殊之处在于 <code>tracked.field(db)</code> 既是 <code>tracked_fn(&#x26;db, input)</code>这个 query 的 input，也是其 output。<code>tracked.field(db)</code> 是在
<code>MyTracked::new</code> 中被创建的，所以是这个 query 的 output。所以，我们能不能加上一条限制：如果某个 dependency/input 同样也是该 query 的 output，我们就认为这个
dependency/input 是有效的。</p>
<p>很遗憾，这仍然有漏洞，看下面这个例子。</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">tracked</span> = MyTracked::<span class="hljs-title function_ invoke__">new</span>(db, input.<span class="hljs-title function_ invoke__">field</span>(db) * <span class="hljs-number">2</span>);
    <span class="hljs-title function_ invoke__">tracked_fn_extra</span>(tracked)
}

<span class="hljs-meta">#[salsa::tracked]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">tracked_fn_extra</span>(db: &#x26;Db, tracked: MyTracked) <span class="hljs-punctuation">-></span> <span class="hljs-type">u32</span> {
    tracked.<span class="hljs-title function_ invoke__">field</span>(db)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    ...
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input</span> = MyInput::<span class="hljs-title function_ invoke__">new</span>(&#x26;db, <span class="hljs-number">11</span>);
    _ = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input);

    <span class="hljs-comment">// A "synthetic write" causes the system to act *as though* some</span>
    <span class="hljs-comment">// input of durability `durability` has changed. This is mostly</span>
    <span class="hljs-comment">// useful for profiling scenarios.</span>
    db.<span class="hljs-title function_ invoke__">synthetic_write</span>(salsa::Durabiliby::High);
    _ = <span class="hljs-title function_ invoke__">tracked_fn</span>(&#x26;db, input); <span class="hljs-comment">// panic</span>
}
</code></pre>
<p>这个例子的和上一个的区别是，我们并没有在创造 tracked struct 的 query 中使用
tracked struct 的 fields，但是我们间接在 query 依赖的其他 query 中使用了它的
fields。回到这个例子，<code>tracked_fn(db, input)</code> 这个 query 创造了 <code>tracked</code> 这一
tracked struct，但是</p></div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"09_salsa_outdated_tracked_struct","contentHtml":"\u003cp\u003e来来回回讨论了两周，终于把这个 \u003ca href=\"https://github.com/salsa-rs/salsa/pull/413\"\u003ePR\u003c/a\u003e\n合进去了，这是我参与开源项目以来，第一次讨论这么多。通过这个 PR，有很多思考，对Salsa 也有了更深入的理解，值得把它们记录下来\u003c/p\u003e\n\u003cp\u003eIssue: \u003ca href=\"https://github.com/salsa-rs/salsa/issues/407\"\u003ehttps://github.com/salsa-rs/salsa/issues/407\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ePR: \u003ca href=\"https://github.com/salsa-rs/salsa/pull/413\"\u003ehttps://github.com/salsa-rs/salsa/pull/413\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e问题\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e MyTracked {\n    MyTracked::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(db, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db) * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput\u003c/span\u003e = MyInput::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u0026#x26;db, \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003etracked\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input);\n\n    input.\u003cspan class=\"hljs-title function_ invoke__\"\u003eset_field\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e db).\u003cspan class=\"hljs-title function_ invoke__\"\u003eto\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e);\n    dbg!(tracked.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(\u0026#x26;db));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改 \u003ccode\u003einput\u003c/code\u003e 后，\u003ccode\u003etracked\u003c/code\u003e 还有效吗？对于上面这段代码，Salsa 希望在调用\n\u003ccode\u003etracked.field(\u0026#x26;db)\u003c/code\u003e 时 panic。而我们现在的代码，也就是这个 PR 之前，并不会\npanic，会返回上次保存的值 22。\u003c/p\u003e\n\u003ch2\u003eInputs and Outputs\u003c/h2\u003e\n\u003cp\u003e在深入讨论这个问题之前，有必要介绍一下 inputs 和 outputs 这两个概念。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eNOTE:\u003c/em\u003e\u003c/strong\u003e 这里的inputs 和 outputs 都是 salsa 内部实现的概念，不是用户接口\n\u003ca href=\"https://salsa-rs.netlify.app/overview.html#inputs\"\u003einput\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eInputs 就是我们在\u003ca href=\"./07_salsa_dependency.md\"\u003e这篇文章\u003c/a\u003e中讨论的 dependencies。一个\nquery 的 inputs 即这个 query 依赖的其他 query。\u003c/p\u003e\n\u003cp\u003e以下三种东西会视为 query 的 outputs\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e生成的 \u003ca href=\"https://salsa-rs.netlify.app/overview.html#tracked-structs\"\u003etracked struct\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e调用 \u003ca href=\"https://salsa-rs.netlify.app/overview.html#specify-the-result-of-tracked-functions-for-particular-structs\"\u003especify\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003epush 到 \u003ca href=\"https://salsa-rs.netlify.app/overview.html#accumulators\"\u003eaccumulator\u003c/a\u003e 的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eInputs 和 outputs 这两个东西有什么用？Salsa 的核心是尽可能利用之前的计算结果来加快当前的计算，inputs 用来判断之前的计算结果现在仍否可用，outputs 对更多地利用之前的计算结果有帮助。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e MyTracked {\n    MyTracked::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(db, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db) * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 query \u003ccode\u003etracked_fn(db, input)\u003c/code\u003e 来说\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003einputs: \u003ccode\u003einput.field(db)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eoutputs: \u003ccode\u003eMyTracked::new(db, input.field(db) * 2)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果我们发现数据库中存储有 query \u003ccode\u003etracked_fn(db, input)\u003c/code\u003e 的值，我们能直接用这个结果吗？换句话说，我们需要重新计算吗？如果这个结果没有在最新的 \u003ca href=\"https://salsa-rs.netlify.app/plumbing/terminology/revision.html?highlight=revision#revision\"\u003erevision\u003c/a\u003e 下被验证，我们就需要检查这个 query 的 inputs，如果所有的 inputs 在上次计算后都没有改变，就可以下结论之前存储的计算结果仍然是有效的。与此同时，我们还可以认为这个\nquery 的 outputs 在最新的 \u003ca href=\"https://salsa-rs.netlify.app/plumbing/terminology/revision.html?highlight=revision#revision\"\u003erevision\u003c/a\u003e 下得到了验证，因为 Salsa 的一个基本假设就是所有的计算都是确定性的，inputs 不变，outputs 就应该不变。\u003c/p\u003e\n\u003ch2\u003ePanic if outdated\u003c/h2\u003e\n\u003cp\u003e现在再次回到最开始的问题，对于 tracked struct 的 fields，一旦发现它过时了，就应该 panic。怎么判断它是否过时了呢？如果保存的旧值的 \u003ccode\u003everified_at\u003c/code\u003e 小于系统的\n\u003ccode\u003ecurrent_revision\u003c/code\u003e，我们就说这个值过时了（我们这里对“过时”的讨论是针对 tracked\nstruct 的）。看看我们上面这个例子，改变 input 的时候，\u003ccode\u003ecurrent_revision\u003c/code\u003e 就会\n+1，大于 \u003ccode\u003etracked.field(\u0026#x26;db)\u003c/code\u003e 查询到的值的\u003ccode\u003everified_at\u003c/code\u003e，所以应该\npanic。（reference:\n\u003ca href=\"https://github.com/salsa-rs/salsa/issues/407#issuecomment-1244550905%EF%BC%89\"\u003ehttps://github.com/salsa-rs/salsa/issues/407#issuecomment-1244550905）\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e看起来合理，但这样改之后，之前的测试有的通不过了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003etracked\u003c/span\u003e = MyTracked::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(db, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db) * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n    tracked.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput\u003c/span\u003e = MyInput::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u0026#x26;db, \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e);\n    _ = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input);\n\n    \u003cspan class=\"hljs-comment\"\u003e// A \"synthetic write\" causes the system to act *as though* some\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// input of durability `durability` has changed. This is mostly\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// useful for profiling scenarios.\u003c/span\u003e\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003esynthetic_write\u003c/span\u003e(salsa::Durabiliby::High);\n    _ = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input); \u003cspan class=\"hljs-comment\"\u003e// panic\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第二次调用 \u003ccode\u003etracked_fn\u003c/code\u003e 会 panic，这里真的应该 panic 吗？对于整个系统来说，我们更改了部分输入，但并没有更改这里的 \u003ccode\u003einput\u003c/code\u003e，所以保存的 \u003ccode\u003etracked_fn(\u0026#x26;db, input)\u003c/code\u003e\n旧值仍然是有效的，这种情况正是我们希望 Salsa 帮我们节省的计算。\u003c/p\u003e\n\u003cp\u003e这个例子的特殊之处在 \u003ccode\u003etracked\u003c/code\u003e（准确来说应该是 \u003ccode\u003etracked.field\u003c/code\u003e） 既是\n\u003ccode\u003etracked_fn(\u0026#x26;db, input)\u003c/code\u003e 的 input，又是它的output。\u003c/p\u003e\n\u003cp\u003e第二次调用 \u003ccode\u003etracked_fn(\u0026#x26;db, input)\u003c/code\u003e，发现 db 中保存有之前的计算结果，但它可能是过时的，因为它对应的 \u003ccode\u003everified_at\u003c/code\u003e 小于 \u003ccode\u003ecurrent_revision\u003c/code\u003e （这里讨论的是tracked\nfunction，所以并不一定是过时的，和上面讨论的 tracked struct 不一样）。这时，我们需要 \u003ca href=\"https://github.com/salsa-rs/salsa/blob/2ffe4a78a824acb8c73e77497e4c2c469fcbed37/components/salsa-2022/src/function/maybe_changed_after.rs#L145\"\u003edeep verify\u003c/a\u003e，检查这个 query 的所有 inputs 在其 \u003ccode\u003everified_at\u003c/code\u003e 之后有没有改变。\u003ccode\u003etracked.field(db)\u003c/code\u003e 就是它的一个 input，显然它的 \u003ccode\u003everified_at\u003c/code\u003e 小于\n\u003ccode\u003ecurrent_revision\u003c/code\u003e，前面已经提到\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于 tracked struct 的 fields，一旦发现它 outdated，就应该 panic。如果保存的旧\n值的 \u003ccode\u003everified_at\u003c/code\u003e 小于 \u003ccode\u003ecurrent_revision\u003c/code\u003e，我们就说这个旧值outdated。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e MyTracked {\n    MyTracked::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(db, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db) * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput\u003c/span\u003e = MyInput::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u0026#x26;db, \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e);\n    _ = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input);\n\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003esynthetic_write\u003c/span\u003e(salsa::Durabiliby::High);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003etracked\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input);\n    dbg!(tracked.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(\u0026#x26;db));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果改写成上面这样，就可以正常工作了。第二次调用 \u003ccode\u003etracked_fn(\u0026#x26;db, input)\u003c/code\u003e 发现保存的旧值是有效的，不用重新计算。在验证完这个 query 之后，我们认为这个它的所有\noutputs 也在\u003ccode\u003ecurrent_revision\u003c/code\u003e 下得到了验证，也是有效的，即更新 outputs 的\n\u003ccode\u003everified_at\u003c/code\u003e 为\u003ccode\u003ecurrent_revision\u003c/code\u003e。所以接下来调用 \u003ccode\u003etracked.field(\u0026#x26;db)\u003c/code\u003e 时，它的\n\u003ccode\u003everified_at\u003c/code\u003e 等于 \u003ccode\u003ecurrent_revision\u003c/code\u003e，这个 field 的旧值也是有效的。\u003c/p\u003e\n\u003cp\u003e如果一个 tracked struct 既是一个 query 的 input，又是其 output，在验证这个 query\n的\u003cstrong\u003e过程中\u003c/strong\u003e，我们还没来得及更新 outputs 的 \u003ccode\u003everified_at\u003c/code\u003e（\u003cstrong\u003e必须在验证结束后才能更新其 outputs\u003c/strong\u003e)，就要将它作为input使用，这时它的 \u003ccode\u003everified_at\u003c/code\u003e 小于\n\u003ccode\u003ecurrent_revision\u003c/code\u003e，所以会 panic。\u003c/p\u003e\n\u003ch2\u003eIs it really outdated?\u003c/h2\u003e\n\u003cp\u003e上一节中 \u003ccode\u003etracked.field(db)\u003c/code\u003e 其实是可用的，我们单纯用它的 \u003ccode\u003everified_at\u003c/code\u003e 做比较是有漏洞的。这个场景的特殊之处在于 \u003ccode\u003etracked.field(db)\u003c/code\u003e 既是 \u003ccode\u003etracked_fn(\u0026#x26;db, input)\u003c/code\u003e这个 query 的 input，也是其 output。\u003ccode\u003etracked.field(db)\u003c/code\u003e 是在\n\u003ccode\u003eMyTracked::new\u003c/code\u003e 中被创建的，所以是这个 query 的 output。所以，我们能不能加上一条限制：如果某个 dependency/input 同样也是该 query 的 output，我们就认为这个\ndependency/input 是有效的。\u003c/p\u003e\n\u003cp\u003e很遗憾，这仍然有漏洞，看下面这个例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn\u003c/span\u003e(db: \u0026#x26;Db, input: MyInput) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003etracked\u003c/span\u003e = MyTracked::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(db, input.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db) * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn_extra\u003c/span\u003e(tracked)\n}\n\n\u003cspan class=\"hljs-meta\"\u003e#[salsa::tracked]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etracked_fn_extra\u003c/span\u003e(db: \u0026#x26;Db, tracked: MyTracked) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e {\n    tracked.\u003cspan class=\"hljs-title function_ invoke__\"\u003efield\u003c/span\u003e(db)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput\u003c/span\u003e = MyInput::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u0026#x26;db, \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e);\n    _ = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input);\n\n    \u003cspan class=\"hljs-comment\"\u003e// A \"synthetic write\" causes the system to act *as though* some\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// input of durability `durability` has changed. This is mostly\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// useful for profiling scenarios.\u003c/span\u003e\n    db.\u003cspan class=\"hljs-title function_ invoke__\"\u003esynthetic_write\u003c/span\u003e(salsa::Durabiliby::High);\n    _ = \u003cspan class=\"hljs-title function_ invoke__\"\u003etracked_fn\u003c/span\u003e(\u0026#x26;db, input); \u003cspan class=\"hljs-comment\"\u003e// panic\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个例子的和上一个的区别是，我们并没有在创造 tracked struct 的 query 中使用\ntracked struct 的 fields，但是我们间接在 query 依赖的其他 query 中使用了它的\nfields。回到这个例子，\u003ccode\u003etracked_fn(db, input)\u003c/code\u003e 这个 query 创造了 \u003ccode\u003etracked\u003c/code\u003e 这一\ntracked struct，但是\u003c/p\u003e","title":"WIP: Salsa: Is the tracked struct valid?","date":"2022-09-26"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"09_salsa_outdated_tracked_struct"},"buildId":"ZhnmZdMHvYJ54x3heEJPU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>