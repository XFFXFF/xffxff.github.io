<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>Salsa 和 functools.cache 有什么不同？</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/dba152634a942a1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dba152634a942a1a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/69a316e8a13b4830.css" as="style"/><link rel="stylesheet" href="/_next/static/css/69a316e8a13b4830.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-d719a31ca00eb19c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fcb060ba8fa2b368.js" defer=""></script><script src="/_next/static/chunks/640-1a3a0dc0790efd2e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-03d1a37039c741de.js" defer=""></script><script src="/_next/static/ZhnmZdMHvYJ54x3heEJPU/_buildManifest.js" defer=""></script><script src="/_next/static/ZhnmZdMHvYJ54x3heEJPU/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><main><article><h1 class="utils_headingXl__u25Y2">Salsa 和 functools.cache 有什么不同？</h1><div class="utils_lightText__eUzGY"><time dateTime="2022-12-15">December 15, 2022</time></div><div><p>我第一次听说 Salsa，第一次听说增量计算（incremental computation）的时候，就有一个疑问：这和 Python 中的 <a href="https://docs.python.org/3/library/functools.html#functools.cache"><code>functools.cache</code></a> 有什么区别？</p>
<p>现在我对 Salsa 更熟悉了，再次面对这个问题的时候，仍然不能很好地回答这个问题，但也有些想法，先记录下来。</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>(input: Input) <span class="hljs-punctuation">-></span> Output {
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    ...
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output1</span> = <span class="hljs-title function_ invoke__">func</span>(input)
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output2</span> = <span class="hljs-title function_ invoke__">func</span>(input) <span class="hljs-comment">// do not need to execute func again</span>
}
</code></pre>
<p>输入同样的 <code>input</code>，第二次调用 <code>func</code> 时，可以直接从缓存中读取结果，而不需要再次执行 <code>func</code>。对于每一个不同的 <code>input</code>，保存之前的计算结果，下次调用时先查找数据库，没有找到才执行计算，Python 中的 <code>functools.cache</code> 就是这么做的。当然，还可以使用一些缓存替换策略，比如 LRU， Python 中 <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache"><code>functools.lru_cache</code></a> 就是这么做的。</p>
<p>Salsa 是这么做的吗？显然不是。至少 Salsa 使用起来要比 <code>functools.cache</code> 复杂得多 ^_^。</p>
<p>我能明显感觉到，Salsa 和 <code>functools.cache</code> 是有很大区别的，但这个区别到底是什么，我好像又说不清楚。。。我好像有点思路，我尝试捋一捋</p>
<p>Salsa 想解决的问题，或者说适用的场景并不是我上面伪代码所示的，而应该像这样</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = ...;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output</span> = <span class="hljs-title function_ invoke__">your_program</span>(&#x26;input);
        <span class="hljs-title function_ invoke__">modify</span>(&#x26;<span class="hljs-keyword">mut</span> input);
    }
}
</code></pre>
<blockquote>
<p>You start out with an input that has some value. You invoke your program to get back a result. Some time later, you modify the input and invoke your program again. Our goal is to make this second call faster by re-using some of the results from the first call.<br>
-- <a href="https://salsa-rs.netlify.app/overview.html#goal-of-salsa">https://salsa-rs.netlify.app/overview.html#goal-of-salsa</a></p>
</blockquote>
<p>一个重要的点是，我们是在 loop 之中不断修改 <code>input</code>。如果换做 <code>functools.cache</code>，它解决的问题应该是</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input0</span> = ...;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output</span> = <span class="hljs-title function_ invoke__">your_program</span>(&#x26;input0);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input1</span> = ...;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output</span> = <span class="hljs-title function_ invoke__">your_program</span>(&#x26;input1);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input2</span> = ...;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output</span> = <span class="hljs-title function_ invoke__">your_program</span>(&#x26;input2);

    ...
}
</code></pre>
<p>Salsa 强调的是 <code>input</code> change，而 <code>functools.cache</code> 是没有 <code>input</code> change 的，只有不同的 <code>input</code>。</p>
<p>另一方面，在 <code>functools.cache</code> 中，每个 <code>input</code> 地位是同等的</p>
<p><img src="/10/input-output.png" alt="">
<img src="../public/10/input-output.png" alt=""></p>
<p>而对 Salsa 来说，一个 <code>input</code> 如果发生了改变，那么它之前的版本就没有用了，所有为旧 <code>input</code> 保存的计算结果都可以丢弃了。Salsa 系统中，是没有太大的存储压力的，这一点和 <code>functools.cache</code> 是非常不一样的，完全可以以 Salsa 为核心写一个复杂软件，比如 <code>rust-analyzer</code>，但无法想象以 <code>functools.cache</code> 为核心构造一个软件。</p>
<p><img src="/10/input-version.png" alt="">
<img src="../public/10/input-version.png" alt=""></p></div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"10_salsa_red_green_algorithm","contentHtml":"\u003cp\u003e我第一次听说 Salsa，第一次听说增量计算（incremental computation）的时候，就有一个疑问：这和 Python 中的 \u003ca href=\"https://docs.python.org/3/library/functools.html#functools.cache\"\u003e\u003ccode\u003efunctools.cache\u003c/code\u003e\u003c/a\u003e 有什么区别？\u003c/p\u003e\n\u003cp\u003e现在我对 Salsa 更熟悉了，再次面对这个问题的时候，仍然不能很好地回答这个问题，但也有些想法，先记录下来。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(input: Input) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Output {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input)\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input) \u003cspan class=\"hljs-comment\"\u003e// do not need to execute func again\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输入同样的 \u003ccode\u003einput\u003c/code\u003e，第二次调用 \u003ccode\u003efunc\u003c/code\u003e 时，可以直接从缓存中读取结果，而不需要再次执行 \u003ccode\u003efunc\u003c/code\u003e。对于每一个不同的 \u003ccode\u003einput\u003c/code\u003e，保存之前的计算结果，下次调用时先查找数据库，没有找到才执行计算，Python 中的 \u003ccode\u003efunctools.cache\u003c/code\u003e 就是这么做的。当然，还可以使用一些缓存替换策略，比如 LRU， Python 中 \u003ca href=\"https://docs.python.org/3/library/functools.html#functools.lru_cache\"\u003e\u003ccode\u003efunctools.lru_cache\u003c/code\u003e\u003c/a\u003e 就是这么做的。\u003c/p\u003e\n\u003cp\u003eSalsa 是这么做的吗？显然不是。至少 Salsa 使用起来要比 \u003ccode\u003efunctools.cache\u003c/code\u003e 复杂得多 ^_^。\u003c/p\u003e\n\u003cp\u003e我能明显感觉到，Salsa 和 \u003ccode\u003efunctools.cache\u003c/code\u003e 是有很大区别的，但这个区别到底是什么，我好像又说不清楚。。。我好像有点思路，我尝试捋一捋\u003c/p\u003e\n\u003cp\u003eSalsa 想解决的问题，或者说适用的场景并不是我上面伪代码所示的，而应该像这样\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput\u003c/span\u003e = ...;\n    \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eyour_program\u003c/span\u003e(\u0026#x26;input);\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003emodify\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e input);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou start out with an input that has some value. You invoke your program to get back a result. Some time later, you modify the input and invoke your program again. Our goal is to make this second call faster by re-using some of the results from the first call.\u003cbr\u003e\n-- \u003ca href=\"https://salsa-rs.netlify.app/overview.html#goal-of-salsa\"\u003ehttps://salsa-rs.netlify.app/overview.html#goal-of-salsa\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e一个重要的点是，我们是在 loop 之中不断修改 \u003ccode\u003einput\u003c/code\u003e。如果换做 \u003ccode\u003efunctools.cache\u003c/code\u003e，它解决的问题应该是\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput0\u003c/span\u003e = ...;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eyour_program\u003c/span\u003e(\u0026#x26;input0);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput1\u003c/span\u003e = ...;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eyour_program\u003c/span\u003e(\u0026#x26;input1);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput2\u003c/span\u003e = ...;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eyour_program\u003c/span\u003e(\u0026#x26;input2);\n\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSalsa 强调的是 \u003ccode\u003einput\u003c/code\u003e change，而 \u003ccode\u003efunctools.cache\u003c/code\u003e 是没有 \u003ccode\u003einput\u003c/code\u003e change 的，只有不同的 \u003ccode\u003einput\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e另一方面，在 \u003ccode\u003efunctools.cache\u003c/code\u003e 中，每个 \u003ccode\u003einput\u003c/code\u003e 地位是同等的\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/10/input-output.png\" alt=\"\"\u003e\n\u003cimg src=\"../public/10/input-output.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e而对 Salsa 来说，一个 \u003ccode\u003einput\u003c/code\u003e 如果发生了改变，那么它之前的版本就没有用了，所有为旧 \u003ccode\u003einput\u003c/code\u003e 保存的计算结果都可以丢弃了。Salsa 系统中，是没有太大的存储压力的，这一点和 \u003ccode\u003efunctools.cache\u003c/code\u003e 是非常不一样的，完全可以以 Salsa 为核心写一个复杂软件，比如 \u003ccode\u003erust-analyzer\u003c/code\u003e，但无法想象以 \u003ccode\u003efunctools.cache\u003c/code\u003e 为核心构造一个软件。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/10/input-version.png\" alt=\"\"\u003e\n\u003cimg src=\"../public/10/input-version.png\" alt=\"\"\u003e\u003c/p\u003e","title":"Salsa 和 functools.cache 有什么不同？","date":"2022-12-15"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"10_salsa_red_green_algorithm"},"buildId":"ZhnmZdMHvYJ54x3heEJPU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>