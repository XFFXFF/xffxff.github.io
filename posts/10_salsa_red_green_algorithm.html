<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css"/><title>WIP: Salsa: The red-green Algorithm</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/dba152634a942a1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dba152634a942a1a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/69a316e8a13b4830.css" as="style"/><link rel="stylesheet" href="/_next/static/css/69a316e8a13b4830.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-d719a31ca00eb19c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fcb060ba8fa2b368.js" defer=""></script><script src="/_next/static/chunks/640-1a3a0dc0790efd2e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-03d1a37039c741de.js" defer=""></script><script src="/_next/static/sqKxd1397smFrMRrRkMHW/_buildManifest.js" defer=""></script><script src="/_next/static/sqKxd1397smFrMRrRkMHW/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><main><article><h1 class="utils_headingXl__u25Y2">WIP: Salsa: The red-green Algorithm</h1><div class="utils_lightText__eUzGY"><time dateTime="2022-12-02">December 2, 2022</time></div><div><pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>(input: Input) <span class="hljs-punctuation">-></span> Output {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>当 <code>input</code> 不变的时候，我们第二次调用 <code>func</code> ，可以直接从缓存中读取结果，而不需要再次执行 <code>func</code>。</p>
<pre><code class="hljs language-rust">...
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output1</span> = <span class="hljs-title function_ invoke__">func</span>(input)
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output2</span> = <span class="hljs-title function_ invoke__">func</span>(input) <span class="hljs-comment">// do not need to execute func again</span>
assert output1 == output2
</code></pre>
<p>这就是所谓的增量计算，Salsa 提供了工具来帮助我们实现增量计算。</p>
<p>实现增量计算，本质上是因为我们保存了之前的计算结果，如果对于每一个不同的 <code>input</code>，我们都保存了之前的计算结果，存储的压力会很大。</p>
<p><img src="/10/input-output.png" alt=""></p>
<p>在这种模式下，我们不知道哪些 <code>input</code> 是过期的，这些 input 除了创建时间不一样，并没有什么不同。当然，我们可以使用一些缓存替换策略（cache replacement policy）来缓解这个问题，但是我们仍然存储了多余的东西，且可能剔除了一些仍然有用的数据。</p>
<p><img src="/10/input-version.png" alt=""></p>
<p>如果我们给 input 分组呢？我们可以为每一个 <code>input</code> 分配一个版本号，当 <code>input</code> 发生变化的时候，我们就更新版本号。这样，我们就可以知道哪些 <code>input</code> 是过期的了。</p>
<p>对于之前的模式，我们的代码可能是这样的：</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input1</span> = Input { ... }
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output1</span> = <span class="hljs-title function_ invoke__">func</span>(input1)
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input2</span> = Input { ... }
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output2</span> = <span class="hljs-title function_ invoke__">func</span>(input2)
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input3</span> = Input { ... }
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output3</span> = <span class="hljs-title function_ invoke__">func</span>(input3)
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">input4</span> = Input { ... }
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output4</span> = <span class="hljs-title function_ invoke__">func</span>(input4)
</code></pre>
<p>如果将 input 分组的话，我们的代码可能是这样的：</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input1</span> = Input { ... } <span class="hljs-comment">// input 1 version 1</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output1</span> = <span class="hljs-title function_ invoke__">func</span>(input1)
<span class="hljs-title function_ invoke__">change_input</span>(&#x26;<span class="hljs-keyword">mut</span> input1) <span class="hljs-comment">// input 1 version 2</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output1</span> = <span class="hljs-title function_ invoke__">func</span>(input1) <span class="hljs-comment">// we can safely remove the data stored for input 1 version 1</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input2</span> = Input { ... } <span class="hljs-comment">// input2 version 1</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output2</span> = <span class="hljs-title function_ invoke__">func</span>(input2) 
<span class="hljs-title function_ invoke__">change_input</span>(&#x26;<span class="hljs-keyword">mut</span> input2) <span class="hljs-comment">// input2 version 2</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">output2</span> = <span class="hljs-title function_ invoke__">func</span>(input2) <span class="hljs-comment">// we can safely remove the data stored for input 2 version 1</span>
</code></pre>
<p>简单来说，我们并不会为每个不同的 input 都构造 <code>Input</code> 实例，而是将 input 分组，每个分组只有一个 <code>Input</code> 实例，这个实例的版本号会随着 input 的变化而变化。这样的好处是，我们可以安全地删除同一个分组中过期（低版本）的 input，以及该 input 对应的计算结果。<strong>当然我们的前提假设是，我们对同一分组中旧的 input 不感兴趣.</strong></p></div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"10_salsa_red_green_algorithm","contentHtml":"\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(input: Input) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Output {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当 \u003ccode\u003einput\u003c/code\u003e 不变的时候，我们第二次调用 \u003ccode\u003efunc\u003c/code\u003e ，可以直接从缓存中读取结果，而不需要再次执行 \u003ccode\u003efunc\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e...\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input)\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input) \u003cspan class=\"hljs-comment\"\u003e// do not need to execute func again\u003c/span\u003e\nassert output1 == output2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就是所谓的增量计算，Salsa 提供了工具来帮助我们实现增量计算。\u003c/p\u003e\n\u003cp\u003e实现增量计算，本质上是因为我们保存了之前的计算结果，如果对于每一个不同的 \u003ccode\u003einput\u003c/code\u003e，我们都保存了之前的计算结果，存储的压力会很大。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/10/input-output.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在这种模式下，我们不知道哪些 \u003ccode\u003einput\u003c/code\u003e 是过期的，这些 input 除了创建时间不一样，并没有什么不同。当然，我们可以使用一些缓存替换策略（cache replacement policy）来缓解这个问题，但是我们仍然存储了多余的东西，且可能剔除了一些仍然有用的数据。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/10/input-version.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e如果我们给 input 分组呢？我们可以为每一个 \u003ccode\u003einput\u003c/code\u003e 分配一个版本号，当 \u003ccode\u003einput\u003c/code\u003e 发生变化的时候，我们就更新版本号。这样，我们就可以知道哪些 \u003ccode\u003einput\u003c/code\u003e 是过期的了。\u003c/p\u003e\n\u003cp\u003e对于之前的模式，我们的代码可能是这样的：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput1\u003c/span\u003e = Input { ... }\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input1)\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput2\u003c/span\u003e = Input { ... }\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input2)\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput3\u003c/span\u003e = Input { ... }\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput3\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input3)\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput4\u003c/span\u003e = Input { ... }\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput4\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input4)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果将 input 分组的话，我们的代码可能是这样的：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput1\u003c/span\u003e = Input { ... } \u003cspan class=\"hljs-comment\"\u003e// input 1 version 1\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input1)\n\u003cspan class=\"hljs-title function_ invoke__\"\u003echange_input\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e input1) \u003cspan class=\"hljs-comment\"\u003e// input 1 version 2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input1) \u003cspan class=\"hljs-comment\"\u003e// we can safely remove the data stored for input 1 version 1\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003einput2\u003c/span\u003e = Input { ... } \u003cspan class=\"hljs-comment\"\u003e// input2 version 1\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input2) \n\u003cspan class=\"hljs-title function_ invoke__\"\u003echange_input\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e input2) \u003cspan class=\"hljs-comment\"\u003e// input2 version 2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eoutput2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003efunc\u003c/span\u003e(input2) \u003cspan class=\"hljs-comment\"\u003e// we can safely remove the data stored for input 2 version 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单来说，我们并不会为每个不同的 input 都构造 \u003ccode\u003eInput\u003c/code\u003e 实例，而是将 input 分组，每个分组只有一个 \u003ccode\u003eInput\u003c/code\u003e 实例，这个实例的版本号会随着 input 的变化而变化。这样的好处是，我们可以安全地删除同一个分组中过期（低版本）的 input，以及该 input 对应的计算结果。\u003cstrong\u003e当然我们的前提假设是，我们对同一分组中旧的 input 不感兴趣.\u003c/strong\u003e\u003c/p\u003e","title":"WIP: Salsa: The red-green Algorithm","date":"2022-12-02"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"10_salsa_red_green_algorithm"},"buildId":"sqKxd1397smFrMRrRkMHW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>