{"pageProps":{"postData":{"id":"crafting_interpreters_2","contentHtml":"<p><a href=\"https://link.zhihu.com/?target=http%3A//www.craftinginterpreters.com/\">《Crafting Interpreters》</a>中 jlox（Part I 中用 java 实现的 Lox 语言）用了 recursive descent parsing 去实现 parser。为了偷懒，下面用 RD 代指 recursive descent parsing 这个方法。</p>\n<h2>设计简易计算器</h2>\n<p>假如我们现在要实现一个支持加减乘除的计算器，那 parser 应该怎么设计？</p>\n<ul>\n<li>并不是所有的输入都是支持的，比如输入“1 +/ 2”</li>\n<li>不同运算符优先级不一样，考虑“1 + 2 * 3”，应该先算乘法，再算加法</li>\n<li>当运算符优先级一样时，应该优先算靠左边的</li>\n</ul>\n<p>上面三条都是在定义或者限制计算器的语法规则，我们将语法规则用一套符号语言去表示。</p>\n<pre><code>Expr -> Expr + Term     (1)\n      | Expr - Term     (2)\n      | Term            (3)\nTerm -> Term * Factor   (4)\n      | Term / Factor   (5)\n      | Factor          (6)\nFactor -> Number        (7)\n</code></pre>\n<p>每一行表示一条语法规则，为了方便描述，给每条规则都标了号，这里一共有7条规则。上面的这套符号应该怎么理解呢？箭头左边的表达式可以转换成右边的表达式，“｜”表示逻辑或，比如说 Expr 可以展开成 Expr + Term， Expr - Term 和 Term 中的任何一个， 以\"1 + 2 * 3\" 为例列出每一步展开的过程。</p>\n<pre><code>0.               Expr\n1. 应用规则1      Expr + Term\n2. 应用规则4      Expr + Term * Factor\n3. 应用规则7      Expr + Term * Number\n4. 应用规则6      Expr + Factor * Number\n5. 应用规则7      Expr + Number * Number\n6. 应用规则3      Term + Number * Number\n7. 应用规则6      Factor + Number * Number\n8. 应用规则7      Number + Number * Number\n</code></pre>\n<p>不同运算符的优先级能在上述语法规则中体现吗？可以的，箭头左边的表达式，从上往下优先级递增。</p>\n<p>上述语法真的能 work 吗？这里其实有一个在 RD 中非常出名的问题——Left Recursion</p>\n<p>回到我们展开“1 + 2 * 3”这里例子，在第4行的时候我们应用规则6，将 Term 展开成 Factor，得到了 Expr + Factor * Number。Term 展开成了 Factor，为什么不是 Term * Factor，不是 Term / Factor 呢？这里我们站在上帝视角，知道应该走 Term → Factor → Number 路径才是正确的，但是根据我们的语法规则定义，由“｜”连接起来的都是平等的。好，现在放弃上帝视角，Term 展开成 Term * Factor，Term * Factor 中的 Term 又可以展开成 Term * Factor，现在变成了 Term * Term * Factor，以此类推，将无线递归下去。stack overflow！！！</p>\n<p>怎么解决这个问题呢？其实很简单，表达式展开的时候不要把自身写在最左边</p>\n<pre><code>Expr -> Term + Expr     \n      | Term - Expr     \n      | Term            \nTerm -> Factor * Term   \n      | Factor / Term   \n      | Factor          \nFactor -> Number\n</code></pre>\n<p>写成这样的语法规则能达到我们最开始设计时的那三点要求吗？oh，我们好像还没讨论运算符优先级相同时的情况。</p>\n<p>考虑“1 + 2 + 3”会被 parse 成什么？答案是“(1 + (2 + 3))”，竟然是先算右边的，你可能会觉得先算右边好像也没啥大不了嘛，结果都一样，为啥要强调得先算左边呢？那试试“1 - 2 - 3”呢？为什么会先算右边呢？你可以尝试根据语法规则一步步展开推一下。感兴趣的话，这儿有一份用 python 实现的 parser，语法比我们这个略微复杂一点，（代码不是我写的，我甚至都没有看过，我只看了大佬的博客）。</p>\n<p>刚刚讨论的其实是 parser 中一个非常重要的问题，叫 Asscociativity，像“+”，“-”，“*”，“/”都是 left-associative，“=”是一个典型的 right-associative，“a = b = c”应该被 parse 为 “a = (b = c)”。</p>\n<pre><code>Expr -> Term {+ Term}     \n      | Term {- Term}     \n      | Term            \nTerm -> Factor {* Factor}   \n      | Factor {/ Term}   \n      | Factor          \nFactor -> Number\n</code></pre>\n<p>“{}”表示括号内可以重复一次或多次。（忘了“{}”这个叫中括号还是大括号了。。。）</p>\n<p>这次它真的可以解决 left-associative 的问题，不信你可以推一下（狗头）。</p>\n<h2>优缺点</h2>\n<blockquote>\n<p>Recursive descent parsers are fast, robust, and can support sophisticated error handling. In fact, GCC, V8 (the JavaScript VM in Chrome), Roslyn (the C# compiler written in C#) and many other heavyweight production language implementations use recursive descent.</p>\n</blockquote>\n<p>这是《Crafting Interpreters》中说的，又快有稳定，GCC 都在用。但是下面两篇文章都指出 RD 有性能问题，每个优先级在语法规则中都会有一个单独的 level，直白点，代码中每个优先级会对应一个函数，优先级层数越多，对应的函数也就越多。即使输入只有一个 token “1”，也需要先后调用 expr，term，factor 函数。</p>\n<p><a href=\"https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm\">https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a></p>\n<p><a href=\"https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/\">https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></p>\n<p>这一块还没有怎么调研，先挖个坑吧。</p>\n<h2>参考</h2>\n<p>贴一下我觉得有用的文章，有用程度和先后顺序有关</p>\n<p><a href=\"https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/\">https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></p>\n<p><a href=\"https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm\">https://web.archive.org/web/20191231231734/www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a></p>\n<p>《Engineering A Compiler (second edition)》3.3 left recursion</p>\n<p><a href=\"http://craftinginterpreters.com/parsing-expressions.html#ambiguity-and-the-parsing-game\">http://craftinginterpreters.com/parsing-expressions.html#ambiguity-and-the-parsing-game</a></p>\n<h2>Implementing it in Rust</h2>\n<p>最后用 rust 实现了最终版的 RD，手动 lexer，哈哈哈</p>\n<pre><code class=\"hljs language-Rust\"><span class=\"hljs-comment\">/* \nExpr -> Term {+ Term}     \n      | Term {- Term}     \n      | Term            \nTerm -> Factor {* Factor}   \n      | Factor {/ Factor}   \n      | Factor          \nFactor -> Number        \n\n */</span>\n<span class=\"hljs-keyword\">use</span> std::fmt;\n<span class=\"hljs-keyword\">use</span> std::iter::Peekable;\n\n<span class=\"hljs-meta\">#[derive(Debug, Clone)]</span>\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Token</span> {\n    <span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-type\">u32</span>),\n    Plus,\n    Minus,\n    Star,\n    Slash,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">fmt</span>::Display <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Token</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fmt</span>(&#x26;<span class=\"hljs-keyword\">self</span>, f: &#x26;<span class=\"hljs-keyword\">mut</span> fmt::Formatter&#x3C;<span class=\"hljs-symbol\">'_</span>>) <span class=\"hljs-punctuation\">-></span> fmt::<span class=\"hljs-type\">Result</span> {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Token::<span class=\"hljs-title function_ invoke__\">Number</span>(n) => <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"{}\"</span>, n),\n            Token::Plus => <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"+\"</span>),\n            Token::Minus => <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"-\"</span>),\n            Token::Star => <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"*\"</span>),\n            Token::Slash => <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"/\"</span>),\n        }\n    }\n}\n\n<span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Expr</span> {\n    <span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-type\">u32</span>),\n    <span class=\"hljs-title function_ invoke__\">Binary</span>(<span class=\"hljs-type\">Box</span>&#x3C;Expr>, Token, <span class=\"hljs-type\">Box</span>&#x3C;Expr>),\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">fmt</span>::Display <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Expr</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fmt</span>(&#x26;<span class=\"hljs-keyword\">self</span>, f: &#x26;<span class=\"hljs-keyword\">mut</span> fmt::Formatter&#x3C;<span class=\"hljs-symbol\">'_</span>>) <span class=\"hljs-punctuation\">-></span> fmt::<span class=\"hljs-type\">Result</span> {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Expr::<span class=\"hljs-title function_ invoke__\">Number</span>(n) => <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"{}\"</span>, n),\n            Expr::<span class=\"hljs-title function_ invoke__\">Binary</span>(lhs, token, rhs) => {\n                <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"({} \"</span>, lhs)?;\n                <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"{} \"</span>, token)?;\n                <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">\"{})\"</span>, rhs)\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">expr</span>&#x3C;I: <span class=\"hljs-built_in\">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class=\"hljs-keyword\">mut</span> Peekable&#x3C;I>) <span class=\"hljs-punctuation\">-></span> Expr {\n    <span class=\"hljs-title function_ invoke__\">term</span>(token_iter)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">term</span>&#x3C;I: <span class=\"hljs-built_in\">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class=\"hljs-keyword\">mut</span> Peekable&#x3C;I>) <span class=\"hljs-punctuation\">-></span> Expr {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">lhs</span> = <span class=\"hljs-title function_ invoke__\">factor</span>(token_iter);\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(token) = token_iter.<span class=\"hljs-title function_ invoke__\">peek</span>().<span class=\"hljs-title function_ invoke__\">cloned</span>() {\n        <span class=\"hljs-keyword\">match</span> token {\n            Token::Plus | Token::Minus => {\n                token_iter.<span class=\"hljs-title function_ invoke__\">next</span>();\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">rhs</span> = <span class=\"hljs-title function_ invoke__\">factor</span>(token_iter);\n                lhs = Expr::<span class=\"hljs-title function_ invoke__\">Binary</span>(<span class=\"hljs-type\">Box</span>::<span class=\"hljs-title function_ invoke__\">new</span>(lhs), token, <span class=\"hljs-type\">Box</span>::<span class=\"hljs-title function_ invoke__\">new</span>(rhs));\n            }\n            _ => <span class=\"hljs-keyword\">break</span>,\n        }\n    }\n    lhs\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">factor</span>&#x3C;I: <span class=\"hljs-built_in\">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class=\"hljs-keyword\">mut</span> Peekable&#x3C;I>) <span class=\"hljs-punctuation\">-></span> Expr {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">lhs</span> = <span class=\"hljs-title function_ invoke__\">primary</span>(token_iter);\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(token) = token_iter.<span class=\"hljs-title function_ invoke__\">peek</span>().<span class=\"hljs-title function_ invoke__\">cloned</span>() {\n        <span class=\"hljs-keyword\">match</span> token {\n            Token::Slash | Token::Star => {\n                token_iter.<span class=\"hljs-title function_ invoke__\">next</span>();\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">rhs</span> = <span class=\"hljs-title function_ invoke__\">primary</span>(token_iter);\n                lhs = Expr::<span class=\"hljs-title function_ invoke__\">Binary</span>(<span class=\"hljs-type\">Box</span>::<span class=\"hljs-title function_ invoke__\">new</span>(lhs), token, <span class=\"hljs-type\">Box</span>::<span class=\"hljs-title function_ invoke__\">new</span>(rhs));\n            }\n            _ => <span class=\"hljs-keyword\">break</span>,\n        }\n    }\n    lhs\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">primary</span>&#x3C;I: <span class=\"hljs-built_in\">Iterator</span>&#x3C;Item = Token>>(token_iter: &#x26;<span class=\"hljs-keyword\">mut</span> Peekable&#x3C;I>) <span class=\"hljs-punctuation\">-></span> Expr {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(Token::<span class=\"hljs-title function_ invoke__\">Number</span>(n)) = token_iter.<span class=\"hljs-title function_ invoke__\">peek</span>().<span class=\"hljs-title function_ invoke__\">cloned</span>() {\n        token_iter.<span class=\"hljs-title function_ invoke__\">next</span>();\n        <span class=\"hljs-keyword\">return</span> Expr::<span class=\"hljs-title function_ invoke__\">Number</span>(n);\n    }\n    <span class=\"hljs-built_in\">panic!</span>(<span class=\"hljs-string\">\"No more tokens left\"</span>)\n}\n\n<span class=\"hljs-meta\">#[test]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tests</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">tokens</span> = <span class=\"hljs-built_in\">vec!</span>[\n        Token::<span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-number\">1</span>),\n        Token::Plus,\n        Token::<span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-number\">2</span>),\n        Token::Slash,\n        Token::<span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-number\">3</span>),\n    ];\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s</span> = <span class=\"hljs-title function_ invoke__\">expr</span>(&#x26;<span class=\"hljs-keyword\">mut</span> tokens.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">peekable</span>());\n    <span class=\"hljs-built_in\">assert_eq!</span>(s.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">\"(1 + (2 / 3))\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">tokens</span> = <span class=\"hljs-built_in\">vec!</span>[\n        Token::<span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-number\">1</span>),\n        Token::Minus,\n        Token::<span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-number\">2</span>),\n        Token::Plus,\n        Token::<span class=\"hljs-title function_ invoke__\">Number</span>(<span class=\"hljs-number\">3</span>),\n    ];\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s</span> = <span class=\"hljs-title function_ invoke__\">expr</span>(&#x26;<span class=\"hljs-keyword\">mut</span> tokens.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">peekable</span>());\n    <span class=\"hljs-built_in\">assert_eq!</span>(s.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">\"((1 - 2) + 3)\"</span>);\n}\n</code></pre>","title":"《Crafting Interpreters》阅读笔记（二）","date":"2021-10-17"}},"__N_SSG":true}