{"pageProps":{"postData":{"id":"python_mock","contentHtml":"<p>Python 中 <code>unittest.mock</code> 是我经常用到的一个库，它提供了非常方便的 mock 功能，可以帮助我们写出更好的单元测试。本文不是介绍 <code>unittest.mock</code> 的使用，而是探讨它的实现原理，从零开始实现 <code>unittest.mock</code> 中的 <code>Mock</code>，<code>patch</code> 和 <code>patch.object</code>，帮助我们更好地理解它们的工作原理。</p>\n<h2>如何 mock 一个函数</h2>\n<p>假如有一个函数 <code>random_boolean</code>，实现如下：</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> random\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">random_boolean</span>(<span class=\"hljs-params\">threshold=<span class=\"hljs-number\">0.5</span></span>):\n    <span class=\"hljs-keyword\">return</span> random.random() &#x3C; threshold\n</code></pre>\n<p>我现在想给这个函数写一个单元测试，测试它的返回值是否符合预期，应该怎么做呢？</p>\n<p>这时候可以 mock <code>random.random()</code>，让它总是返回小于 0.5 的值，测试 <code>random_boolean</code> 的返回值是否为 <code>True</code>。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> unittest.mock <span class=\"hljs-keyword\">import</span> patch\n<span class=\"hljs-keyword\">from</span> my_module <span class=\"hljs-keyword\">import</span> random_boolean\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_random_boolean</span>():\n    <span class=\"hljs-keyword\">with</span> patch(<span class=\"hljs-string\">'random.random'</span>, new=<span class=\"hljs-keyword\">lambda</span>: random.uniform(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.5</span>)):\n        <span class=\"hljs-keyword\">assert</span> random_boolean() == <span class=\"hljs-literal\">True</span>\n</code></pre>\n<p>接下来如何实现 <code>patch</code>，让它完成上述的功能呢？</p>\n<h3>实现 patch</h3>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> importlib\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Patch</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, target, new</span>):\n        self.target = target\n        self.new = new\n        self.original = <span class=\"hljs-literal\">None</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__enter__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-comment\"># Split the target into module and attribute</span>\n        parts = self.target.split(<span class=\"hljs-string\">'.'</span>)\n        module_name = <span class=\"hljs-string\">'.'</span>.join(parts[:-<span class=\"hljs-number\">1</span>])\n        attr_name = parts[-<span class=\"hljs-number\">1</span>]\n        \n        <span class=\"hljs-comment\"># Import the module and get the original attribute</span>\n        module = importlib.import_module(module_name)\n        self.original = <span class=\"hljs-built_in\">getattr</span>(module, attr_name)\n        \n        <span class=\"hljs-comment\"># Replace the original attribute with the new one</span>\n        <span class=\"hljs-built_in\">setattr</span>(module, attr_name, self.new)\n        <span class=\"hljs-keyword\">return</span> self.new\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__exit__</span>(<span class=\"hljs-params\">self, exc_type, exc_val, exc_tb</span>):\n        <span class=\"hljs-comment\"># Restore the original attribute when exiting the with block</span>\n        parts = self.target.split(<span class=\"hljs-string\">'.'</span>)\n        module_name = <span class=\"hljs-string\">'.'</span>.join(parts[:-<span class=\"hljs-number\">1</span>])\n        attr_name = parts[-<span class=\"hljs-number\">1</span>]\n        module = importlib.import_module(module_name)\n        <span class=\"hljs-built_in\">setattr</span>(module, attr_name, self.original)\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">patch</span>(<span class=\"hljs-params\">target, new</span>):\n    <span class=\"hljs-keyword\">return</span> Patch(target, new)\n</code></pre>\n<p>实现的核心思路是，通过 <code>importlib.import_module</code> 导入需要 patch 的模块（<code>random</code>），然后通过 <code>setattr</code> 将模块中的需要 patch 的属性（random 模块中的 <code>random()</code> 函数）替换为新的值（<code>lambda: random.uniform(0, 0.5)</code>）。替换只在 <code>with</code> 语句块中生效，<code>with</code> 语句块结束后，再将原来的值赋回去。</p>\n<h2>如何 mock 一个类方法</h2>\n<p>假设现在有这样一个类：</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProductionClass</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">return</span> self.something(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">something</span>(<span class=\"hljs-params\">self, a, b, c</span>):\n        <span class=\"hljs-keyword\">pass</span>\n</code></pre>\n<p>我想 mock <code>something</code> 方法，可以用 <code>unittest.mock.patch.object</code> 来实现：</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> unittest.mock <span class=\"hljs-keyword\">import</span> patch\n<span class=\"hljs-keyword\">from</span> my_module <span class=\"hljs-keyword\">import</span> ProductionClass\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_method</span>():\n    <span class=\"hljs-keyword\">with</span> patch.<span class=\"hljs-built_in\">object</span>(ProductionClass, <span class=\"hljs-string\">'something'</span>, new=<span class=\"hljs-keyword\">lambda</span> self, a, b, c: <span class=\"hljs-number\">3</span>) <span class=\"hljs-keyword\">as</span> mock_method:\n        <span class=\"hljs-keyword\">assert</span> ProductionClass().method() == <span class=\"hljs-number\">3</span>\n</code></pre>\n<h3>实现 patch.object</h3>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PatchObject</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, target, attr, new</span>):\n        self.target = target\n        self.attr = attr\n        self.new = new\n        self.original = <span class=\"hljs-literal\">None</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__enter__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-comment\"># Get the original attribute</span>\n        self.original = <span class=\"hljs-built_in\">getattr</span>(self.target, self.attr)\n        \n        <span class=\"hljs-comment\"># Replace the original attribute with the new one</span>\n        <span class=\"hljs-built_in\">setattr</span>(self.target, self.attr, self.new)\n        <span class=\"hljs-keyword\">return</span> self.new\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__exit__</span>(<span class=\"hljs-params\">self, exc_type, exc_val, exc_tb</span>):\n        <span class=\"hljs-comment\"># Restore the original attribute when exiting the with block</span>\n        <span class=\"hljs-built_in\">setattr</span>(self.target, self.attr, self.original)\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">patch_object</span>(<span class=\"hljs-params\">target, attr, new</span>):\n    <span class=\"hljs-keyword\">return</span> PatchObject(target, attr, new)\n</code></pre>\n<p>实现的核心思路是，通过 <code>getattr</code> 获取需要 patch 的属性（<code>something</code> 方法），然后通过 <code>setattr</code> 将属性替换为新的值（<code>lambda self, a, b, c: 3</code>）。替换只在 <code>with</code> 语句块中生效，<code>with</code> 语句块结束后，再将原来的值赋回去。</p>\n<h2>实现 Mock</h2>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mock</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, return_value=<span class=\"hljs-literal\">None</span></span>):\n        self._methods = {}\n        self.return_value = return_value\n        self.call_count = <span class=\"hljs-number\">0</span>\n        self.call_args = <span class=\"hljs-literal\">None</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__getattr__</span>(<span class=\"hljs-params\">self, name</span>):\n        <span class=\"hljs-keyword\">if</span> name <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> self._methods:\n            self._methods[name] = Mock()\n        <span class=\"hljs-keyword\">return</span> self._methods[name]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setattr__</span>(<span class=\"hljs-params\">self, name, value</span>):\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">isinstance</span>(value, Mock):\n            self._methods[name] = value\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-built_in\">super</span>().__setattr__(name, value)\n    \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__call__</span>(<span class=\"hljs-params\">self, *args, **kwargs</span>):\n        self.call_count += <span class=\"hljs-number\">1</span>\n        self.call_args = (args, kwargs)\n        <span class=\"hljs-keyword\">if</span> self.return_value <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n            <span class=\"hljs-keyword\">return</span> Mock()\n        <span class=\"hljs-keyword\">return</span> self.return_value\n</code></pre>\n<p>Mock 类的主要工作原理是，当我们试图访问它的一个属性时，如果这个属性不存在，那么它就会创建一个新的 Mock 实例并返回。这样，我们就可以无限制地访问它的属性，每个属性都是一个新的 Mock 实例。当我们调用 Mock 实例时，它会记录调用的次数和参数，并返回一个预设的值或者一个新的 Mock 实例。</p>\n<hr>\n<p>通过上述的讨论，我们深入地了解了 Python 的 mock 库的实现原理。我们了解了如何通过修改模块的属性来模拟函数或者方法的行为，以及如何通过 Mock 类来模拟对象的行为。然而，实际的 mock 库的实现要比我们讨论的更复杂，它还包括了很多其他的特性，例如 side_effect、call_args_list 等。如果你对这个主题感兴趣，我鼓励你去阅读 Python 官方文档或者 mock 库的源代码，以获取更深入的理解。</p>","title":"深入理解 Python Mock 库：Mock，patch 和 patch.object 的实现原理","date":"2023-07-08"}},"__N_SSG":true}