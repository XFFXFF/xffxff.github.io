{"pageProps":{"postData":{"id":"red_green_tree","contentHtml":"<p>本文源自我在知乎的一个回答，原文地址：<a href=\"https://www.zhihu.com/question/525030607/answer/2418851335\">https://www.zhihu.com/question/525030607/answer/2418851335</a></p>\n<p>原问题为：</p>\n<blockquote>\n<p>仓库：<a href=\"https://github.com/rust-analyzer/rowan\">https://github.com/rust-analyzer/rowan</a><br>\n参考文献：<a href=\"https://blog.walterlv.com/post/the-red-green-tree-of-roslyn.html\">理解 Roslyn 中的红绿树（Red-Green Trees</a><br>\n这种设计似乎可以应用在lsp中作为提高语言增量解析和构建的效率。<br>\n不过尚未深刻理解其算法的精妙~</p>\n</blockquote>\n<h2>回答</h2>\n<p>题主给了篇参考文章</p>\n<blockquote>\n<p>Roslyn 一开始就将漂亮的 API 作为目标的一部分，同时还要非常高的性能；所以 Roslyn 的开发团队需要找到一种特殊的数据结构来描述语言（如 C#）的语法。这种数据结构要满足这些期望的要求：</p>\n<ol>\n<li>不可变（Immutable）</li>\n<li>树的形式</li>\n<li>可以容易地访问父节点和子节点</li>\n<li>可以非常容易地将任何一个节点对应到源代码文件的一段文本区间</li>\n<li>可重用（Persistent）</li>\n</ol>\n</blockquote>\n<p>从第 4 点开始说，这是一个很常见的需求，想想我们的编译器报错信息，能够指出错误出现在源文件的哪一行哪一列。我们可能设计出下面这种数据结构作为 syntax tree</p>\n<pre><code class=\"hljs language-Rust\"><span class=\"hljs-meta\">#[derive(PartialEq, Eq, Clone, Copy)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SyntaxKind</span>(<span class=\"hljs-type\">u16</span>);\n\n<span class=\"hljs-meta\">#[derive(PartialEq, Eq, Clone)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\n    kind: SyntaxKind,\n    text_len: <span class=\"hljs-type\">usize</span>,\n    children: <span class=\"hljs-type\">Vec</span>&#x3C;Arc&#x3C;Either&#x3C;Node, Token>>>,\n    offset: <span class=\"hljs-type\">usize</span>\n}\n\n<span class=\"hljs-meta\">#[derive(PartialEq, Eq, Clone)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Token</span> {\n    kind: SyntaxKind,\n    text: <span class=\"hljs-type\">String</span>,\n    offset: <span class=\"hljs-type\">usize</span>\n}\n\n<span class=\"hljs-comment\">// https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md</span>\n</code></pre>\n<p>对于 <code>1 + 2</code> ，我们会得到如下的 syntax tree</p>\n<pre><code>               +-----------------+\n               |  Node           |\n               |  kind: BinExpr  |\n      +--------+  text_len: 5    +-------+\n      |        |  offset: 0      |       |\n      |        +-------+---------+       |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      |                |                 |\n      v                v                 v\n+----------+    +------------+    +-----------+\n|Token     |    | Token      |    | Token     |\n|kind: int |    | kind: plus |    | kind: int |\n|text: 1   |    | text: +    |    | text: 2   |\n|offset: 0 |    | offset: 2  |    | offset: 4 |\n+----------+    +------------+    +-----------+\n</code></pre>\n<p>如果我们把 source code 简单改一下，多加一个 whitespace，即 <code>1  + 2</code> ，我们的 syntax tree 会发生变化吗？当然，从 + 开始所有节点的 offset 都要发生变化。真实场景中 source code 会复杂得多，加一个 whitespace，整个 syntax tree 就作废了。太浪费了，加 whitespace，加 comments 其实并不影响我们的 syntax，有没有方法使得语法无关的修改不改变 syntax tree 呢？</p>\n<p>很容易能想到，我们的 node 不包含 offset 不就可以了吗？问题是如果不包含 offset，“任何一个节点对应到源代码文件的一段文本区间” 这条就不满足了。</p>\n<p>我们可以把 whitespace 也放到 syntax tree 中。</p>\n<pre><code>                               +---------------+\n                               | Node          |\n      +---------------+--------+ kind: BinExpr +---------+----------------+\n      |               |        | text_len: 5   |         |                |\n      |               |        +-------+-------+         |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      |               |                |                 |                |\n      v               v                v                 v                v\n+-----------+   +-----------+    +------------+    +-----------+    +-----------+\n| Token     |   | Token     |    | Token      |    | Token     |    | Token     |\n| kind: int |   | kind: wp  |    | kind: plus |    | kind: wp  |    | kind: int |\n| text: 1   |   | text: ' ' |    | text: +    |    | text: ' ' |    | text: 2   |\n+-----------+   +-----------+    +------------+    +-----------+    +-----------+\n</code></pre>\n<p>现在 syntax tree 已经包含了所有 source code 的信息，当然可以推断出每个 node 对应源代码的文本区间。</p>\n<p>题主提到的 <a href=\"https://blog.walterlv.com/post/the-red-green-tree-of-roslyn.html\">rust-analyzer/rowan</a> ，readme 中的第一句话</p>\n<blockquote>\n<p>Rowan is a library for lossless syntax trees</p>\n</blockquote>\n<p>lossless 指的应该就如我们上面所做的，source code 的任何东西都没有丢失，包括 whitespace，comments。</p>\n<p>另一个有趣的事情是，现在的 syntax tree 有两个节点都是 whitespace，这两个节点有什么不同吗？没有任何不同，所以这两个节点是可以共用的。再比如 <code>1 + 1</code> 中的两个节点 <code>1</code> 也是可以共用的，这应该就是第 5 点“可重用”所要表达的意思吧。</p>\n<blockquote>\n<p>这种设计似乎可以应用在 lsp 中作为提高语言增量解析和构建的效率。</p>\n</blockquote>\n<p>那就以 lsp 为例谈一谈增量编译/计算。现在我们需要 lsp 帮我们做代码自动补全，流程大概像这样</p>\n<ul>\n<li>vscode：嘿，language server，帮我编辑器光标所在的位置做自动补全</li>\n<li>language server: 收到。哈喽，type checker，帮我做一下类型检查</li>\n<li>type checker: 好的，那我得先知道 AST</li>\n<li>ast creater：没问题。嗨，parser，帮我生成一下 syntax tree</li>\n<li>parser: 根据 source code 生成 syntax tree 。</li>\n</ul>\n<p><img src=\"https://pic4.zhimg.com/80/v2-a0480cc5840280f58e321a44386bf645_720w.jpg\" alt=\"image\"></p>\n<p>如果哪个过程发现本次计算的结果和上次的结果没有变化，就告诉它的调用方说，计算结果和之前没有变化，你不用再重新计算了。比如说我就只在代码中多加了一个 whitespace，那 syntax tree 不会发生变化，后面的 ast， type check 都不用重新算了，直接用之前缓存的结果就好。</p>\n<p>增量计算的话可以看看 <a href=\"https://github.com/salsa-rs/salsa\">Salsa</a>，rust-analyzer 用了这个库。</p>\n<p>其实上面说的都是“绿树”部分。我觉得“红树”主要为了解决访问父节点的问题，另外也可以更方便算每个节点的 offset。</p>\n<pre><code class=\"hljs language-Rust\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">SyntaxNode</span> = Arc&#x3C;SyntaxData>;\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SyntaxData</span> {\n    offset: <span class=\"hljs-type\">usize</span>,\n    parent: <span class=\"hljs-type\">Option</span>&#x3C;SyntaxNode>,\n    green: Arc&#x3C;GreeNode>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">SyntaxNode</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new_root</span>(root: Arc&#x3C;GreenNode>) <span class=\"hljs-punctuation\">-></span> SyntaxNode {\n        Arc::<span class=\"hljs-title function_ invoke__\">new</span>(SyntaxData {\n            offset: <span class=\"hljs-number\">0</span>,\n            parent: <span class=\"hljs-literal\">None</span>,\n            green: root,\n        })\n    }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">parent</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Option</span>&#x3C;SyntaxNode> {\n        <span class=\"hljs-keyword\">self</span>.parent.<span class=\"hljs-title function_ invoke__\">clone</span>()\n    }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">children</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Iterator</span>&#x3C;Item = SyntaxNode> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">offset</span> = <span class=\"hljs-keyword\">self</span>.offset;\n        <span class=\"hljs-keyword\">self</span>.green.<span class=\"hljs-title function_ invoke__\">children</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|green_child| {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">child_offset</span> = offset;\n            offset += green_child.text_len;\n            Arc::<span class=\"hljs-title function_ invoke__\">new</span>(SyntaxData {\n                offset: child_offset,\n                parent: <span class=\"hljs-title function_ invoke__\">Some</span>(Arc::<span class=\"hljs-title function_ invoke__\">clone</span>(<span class=\"hljs-keyword\">self</span>)),\n                green: Arc::<span class=\"hljs-title function_ invoke__\">clone</span>(green_child),\n            })\n        })\n    }\n}\n<span class=\"hljs-comment\">// https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md</span>\n</code></pre>\n<p>用起来大概像这样</p>\n<pre><code class=\"hljs language-Rust\"><span class=\"hljs-comment\">// 1 + 2</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">addition_red_node</span> = SyntaxNode::<span class=\"hljs-title function_ invoke__\">new_root</span>(addtion_green_node);\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">one</span> = addtion_red_node.<span class=\"hljs-title function_ invoke__\">children</span>().<span class=\"hljs-title function_ invoke__\">next</span>().<span class=\"hljs-title function_ invoke__\">unwarp</span>()\n<span class=\"hljs-built_in\">println!</span>(one.<span class=\"hljs-title function_ invoke__\">parent</span>().unwrap) <span class=\"hljs-comment\">// syntax node bin_expr(1,plus, 2)</span>\n</code></pre>\n<p>另外注意到，红树的节点维护的都是指向绿树节点的 pointer/reference，构建红树并不需要对绿树做 deep copy，代价会比较小。</p>\n<p>对于第 1 点 immutable，我不懂，希望懂的人指点。</p>\n<p>Rust analyzer 的作者在 youtube 上讲过红绿树，用 rust 实现了一个简单的红绿树，推荐给各位 <a href=\"https://youtu.be/n5LDjWIAByM\">https://youtu.be/n5LDjWIAByM</a></p>","title":"如何看待 rust 体系中 rowan 的红绿树","date":"2022-04-01"}},"__N_SSG":true}