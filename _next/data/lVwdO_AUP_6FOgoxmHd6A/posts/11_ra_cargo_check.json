{"pageProps":{"postData":{"id":"11_ra_cargo_check","contentHtml":"<p>为什么每次编辑的时候（严格来说是保存文本的时候），RA 都要跑一遍 <code>cargo check</code> ？记得有朋友抱怨说跑 <code>cargo check</code> 时 ide 很卡，编辑体验很不好，总不能做一件吃力不讨好的事情吧。</p>\n<p><img src=\"/11/status_bar.png\" alt=\"\"></p>\n<p>原因就是 <code>cargo check</code> 的报错信息对 RA 非常有用，这些报错信息是 RA diagnostics 的重要部分。</p>\n<p><img src=\"/11/vscode.png\" alt=\"\"></p>\n<p>图中代码 <code>main</code> 函数少了 } ， RA 提示我们有一些错误，其中 <code>this file contains an unclosed delimiter</code> 和 <code>main.rs(1, 11) unclosed delimiter 是 cargo check</code> 给出的，<code>Syntax Error: expected R_CURLY</code> 是 RA 给出的。</p>\n<p>整体思路其实挺简单的，起一个线程跑 cargo check --message-format=json ，这个命令会将报错信息以 json 的格式输出，我贴了一段在下面，它包含具体的报错信息（rendered 和 message 字段），错误的级别（level 字段，error or warning）， 错误发生的位置（spans 字段）。有了这些信息后，RA 就可以把它们展示在 ide 界面上。</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-attr\">\"message\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"rendered\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"error: this file contains an unclosed delimiter\\n --> src/main.rs:2:31\\n  |\\n1 | fn main() {\\n  |           - unclosed delimiter\\n2 |     println!(\\\"Hello World!\\\");\\n  |                               ^\\n\\n\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"children\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"code\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">null</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"level\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"error\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"message\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"this file contains an unclosed delimiter\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"spans\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n      <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"byte_end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">11</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"byte_start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">10</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"column_end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">12</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"column_start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">11</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"expansion\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">null</span></span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"file_name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"src/main.rs\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"is_primary\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"label\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"unclosed delimiter\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"line_end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"line_start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"suggested_replacement\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">null</span></span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"suggestion_applicability\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">null</span></span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"text\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n          <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-attr\">\"highlight_end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">12</span><span class=\"hljs-punctuation\">,</span>\n            <span class=\"hljs-attr\">\"highlight_start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">11</span><span class=\"hljs-punctuation\">,</span>\n            <span class=\"hljs-attr\">\"text\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"fn main() {\"</span>\n          <span class=\"hljs-punctuation\">}</span>\n        <span class=\"hljs-punctuation\">]</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-punctuation\">]</span>\n  <span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>一个新的问题蹦了出来，RA 不也是一个 <code>rust</code> 的编译器前端吗，也可以给出报错信息，为啥还要依赖别人的呢？</p>\n<p>一是给出清晰易读的报错信息并不是一件容易的事情，既然已经有现成的工具可以用，就没必要自己再重复造轮子。vscode 中可以配置 <code>\"rust-analyzer.checkOnSave.enable\": false</code> 来关闭 <code>cargo check</code> ，关闭之后，发现 rust-analyzer 做的 diagnostic 非常有限，比如 println! 少打一个 <code>n</code> , RA 并不会报错，也缺少对 ownership 和 borrow check 的检查。</p>\n<p>二是 RA 是自己重新写的 parser，使用 <code>cargo check</code> 的好处是 RA 不必保证自己的 grammer 和 rustc 完全一致，只需要保证 rustc 能 parse 的 RA 也能 parse 就行，那些 RA 可以 parse 但实际不被 rustc 接受的，cargo check 可以给出报错信息，对于 Language Server 来说足够了。</p>","title":"Rust Analyzer: 为什么要跑 cargo check","date":"2022-06-04"}},"__N_SSG":true}