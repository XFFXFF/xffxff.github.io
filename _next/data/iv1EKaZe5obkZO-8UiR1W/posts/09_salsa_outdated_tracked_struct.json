{"pageProps":{"postData":{"id":"09_salsa_outdated_tracked_struct","contentHtml":"<p>来来回回讨论了两周，终于把这个 <a href=\"https://github.com/salsa-rs/salsa/pull/413\">PR</a>\n合进去了，这是我参与开源项目以来，第一次讨论这么多。通过这个 PR，有很多思考，对Salsa 也有了更深入的理解，值得把它们记录下来</p>\n<p>Issue: <a href=\"https://github.com/salsa-rs/salsa/issues/407\">https://github.com/salsa-rs/salsa/issues/407</a></p>\n<p>PR: <a href=\"https://github.com/salsa-rs/salsa/pull/413\">https://github.com/salsa-rs/salsa/pull/413</a></p>\n<h2>问题</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[salsa::tracked]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class=\"hljs-punctuation\">-></span> MyTracked {\n    MyTracked::<span class=\"hljs-title function_ invoke__\">new</span>(db, input.<span class=\"hljs-title function_ invoke__\">field</span>(db) * <span class=\"hljs-number\">2</span>)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    ...\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">input</span> = MyInput::<span class=\"hljs-title function_ invoke__\">new</span>(&#x26;db, <span class=\"hljs-number\">11</span>);\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">tracked</span> = <span class=\"hljs-title function_ invoke__\">tracked_fn</span>(&#x26;db, input);\n\n    input.<span class=\"hljs-title function_ invoke__\">set_field</span>(&#x26;<span class=\"hljs-keyword\">mut</span> db).<span class=\"hljs-title function_ invoke__\">to</span>(<span class=\"hljs-number\">12</span>);\n    dbg!(tracked.<span class=\"hljs-title function_ invoke__\">field</span>(&#x26;db));\n}\n</code></pre>\n<p>修改 <code>input</code> 后，<code>tracked</code> 还有效吗？对于上面这段代码，Salsa 希望在调用\n<code>tracked.field(&#x26;db)</code> 时 panic。而我们现在的代码，也就是这个 PR 之前，并不会\npanic，会返回上次保存的值 22。</p>\n<h2>Inputs and Outputs</h2>\n<p>在深入讨论这个问题之前，有必要介绍一下 inputs 和 outputs 这两个概念。</p>\n<blockquote>\n<p><strong><em>NOTE:</em></strong> 这里的inputs 和 outputs 都是 salsa 内部实现的概念，不是用户接口\n<a href=\"https://salsa-rs.netlify.app/overview.html#inputs\">input</a></p>\n</blockquote>\n<p>Inputs 就是我们在<a href=\"./07_salsa_dependency.md\">这篇文章</a>中讨论的 dependencies。一个\nquery 的 inputs 即这个 query 依赖的其他 query。</p>\n<p>以下三种东西会视为 query 的 outputs</p>\n<ul>\n<li>生成的 <a href=\"https://salsa-rs.netlify.app/overview.html#tracked-structs\">tracked struct</a></li>\n<li>调用 <a href=\"https://salsa-rs.netlify.app/overview.html#specify-the-result-of-tracked-functions-for-particular-structs\">specify</a></li>\n<li>push 到 <a href=\"https://salsa-rs.netlify.app/overview.html#accumulators\">accumulator</a> 的值</li>\n</ul>\n<p>Inputs 和 outputs 这两个东西有什么用？Salsa 的核心是尽可能利用之前的计算结果来加快当前的计算，inputs 用来判断之前的计算结果现在仍否可用，outputs 对更多地利用之前的计算结果有帮助。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[salsa::tracked]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class=\"hljs-punctuation\">-></span> MyTracked {\n    MyTracked::<span class=\"hljs-title function_ invoke__\">new</span>(db, input.<span class=\"hljs-title function_ invoke__\">field</span>(db) * <span class=\"hljs-number\">2</span>)\n}\n</code></pre>\n<p>对于 query <code>tracked_fn(db, input)</code> 来说</p>\n<ul>\n<li>inputs: <code>input.field(db)</code></li>\n<li>outputs: <code>MyTracked::new(db, input.field(db) * 2)</code></li>\n</ul>\n<p>如果我们发现数据库中存储有 query <code>tracked_fn(db, input)</code> 的值，我们能直接用这个结果吗？换句话说，我们需要重新计算吗？如果这个结果没有在最新的 <a href=\"https://salsa-rs.netlify.app/plumbing/terminology/revision.html?highlight=revision#revision\">revision</a> 下被验证，我们就需要检查这个 query 的 inputs，如果所有的 inputs 在上次计算后都没有改变，就可以下结论之前存储的计算结果仍然是有效的。与此同时，我们还可以认为这个\nquery 的outputs 在最新的 <a href=\"https://salsa-rs.netlify.app/plumbing/terminology/revision.html?highlight=revision#revision\">revision</a> 下得到了验证，因为 Salsa 的一个基本假设就是所有的计算都是确定性的，inputs 不变，outputs 就应该不变。</p>\n<h2>Panic if outdated</h2>\n<p>对于 tracked struct 的 fields，一旦发现它 outdated，就应该 panic。如果保存的旧值的 <code>verified_at</code> 小于 <code>runtime.current_revision</code>，我们就说这个旧值 outdated。看看我们上面这个例子，改变 input 的时候，<code>runtime.current_revision</code> 就会 +1，大于\n<code>tracked.field(&#x26;db)</code> 查询到的值的 <code>verified_at</code>，所以应该 panic。（reference:\n<a href=\"https://github.com/salsa-rs/salsa/issues/407#issuecomment-1244550905\">https://github.com/salsa-rs/salsa/issues/407#issuecomment-1244550905</a>）</p>\n<p>看起来合理，但这样改之后，之前的测试有的通不过了。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[salsa::tracked]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u32</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">tracked</span> = MyTracked::<span class=\"hljs-title function_ invoke__\">new</span>(db, input.<span class=\"hljs-title function_ invoke__\">field</span>(db) * <span class=\"hljs-number\">2</span>);\n    tracked.<span class=\"hljs-title function_ invoke__\">field</span>(db)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    ...\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">input</span> = MyInput::<span class=\"hljs-title function_ invoke__\">new</span>(&#x26;db, <span class=\"hljs-number\">11</span>);\n    _ = <span class=\"hljs-title function_ invoke__\">tracked_fn</span>(&#x26;db, input);\n\n    <span class=\"hljs-comment\">// A \"synthetic write\" causes the system to act *as though* some</span>\n    <span class=\"hljs-comment\">// input of durability `durability` has changed. This is mostly</span>\n    <span class=\"hljs-comment\">// useful for profiling scenarios.</span>\n    db.<span class=\"hljs-title function_ invoke__\">synthetic_write</span>(salsa::Durabiliby::High);\n    _ = <span class=\"hljs-title function_ invoke__\">tracked_fn</span>(&#x26;db, input); <span class=\"hljs-comment\">// panic</span>\n}\n</code></pre>\n<p>第二次调用 <code>tracked_fn</code> 会 panic，但这段代码在 salsa 中绝对应该是合理的。第二次调用 <code>tracked_fn(&#x26;db, input)</code>，我们发现 db 中保存有之前的计算结果，但它可能是过时的，因为它对应的 <code>verified_at</code> 小于 <code>current_revision</code>。这时，我们需要 <a href=\"https://github.com/salsa-rs/salsa/blob/2ffe4a78a824acb8c73e77497e4c2c469fcbed37/components/salsa-2022/src/function/maybe_changed_after.rs#L145\">deep\nverify</a>，检查这个 query 的所有 dependency 在 <code>verified_at</code> 之后有没有改变。（我们在 <a href=\"./07_salsa_dependency.md\">这篇文章</a> 讨论过 query 的 dependency）。对于\n<code>tracked_fn(&#x26;db, input)</code> 来说，一个 dependency 就是 <code>tracked.field(db)</code>，显然它的 <code>verified_at</code> 小于 <code>current_revision</code>，前面已经提到</p>\n<blockquote>\n<p>对于 tracked struct 的 fields，一旦发现它 outdated，就应该 panic。如果保存的旧\n值的 <code>verified_at</code> 小于 <code>runtime.current_revision</code>，我们就说这个旧值\noutdated。</p>\n</blockquote>\n<h2>Is it really outdated?</h2>\n<p>上一节中 <code>tracked.field(db)</code> 其实是可用的，我们单纯用它的 <code>verified_at</code> 做比较是有漏洞的。这个场景的特殊之处在于 <code>tracked.field(db)</code> 既是 <code>tracked_fn(&#x26;db, input)</code>这个 query 的 input，也是其 output。<code>tracked.field(db)</code> 是在\n<code>MyTracked::new</code> 中被创建的，所以是这个 query 的 output。所以，我们能不能加上一条限制：如果某个 dependency/input 同样也是该 query 的 output，我们就认为这个\ndependency/input 是有效的。</p>\n<p>很遗憾，这仍然有漏洞，看下面这个例子。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[salsa::tracked]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tracked_fn</span>(db: &#x26;Db, input: MyInput) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u32</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">tracked</span> = MyTracked::<span class=\"hljs-title function_ invoke__\">new</span>(db, input.<span class=\"hljs-title function_ invoke__\">field</span>(db) * <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-title function_ invoke__\">tracked_fn_extra</span>(tracked)\n}\n\n<span class=\"hljs-meta\">#[salsa::tracked]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tracked_fn_extra</span>(db: &#x26;Db, tracked: MyTracked) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u32</span> {\n    tracked.<span class=\"hljs-title function_ invoke__\">field</span>(db)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    ...\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">input</span> = MyInput::<span class=\"hljs-title function_ invoke__\">new</span>(&#x26;db, <span class=\"hljs-number\">11</span>);\n    _ = <span class=\"hljs-title function_ invoke__\">tracked_fn</span>(&#x26;db, input);\n\n    <span class=\"hljs-comment\">// A \"synthetic write\" causes the system to act *as though* some</span>\n    <span class=\"hljs-comment\">// input of durability `durability` has changed. This is mostly</span>\n    <span class=\"hljs-comment\">// useful for profiling scenarios.</span>\n    db.<span class=\"hljs-title function_ invoke__\">synthetic_write</span>(salsa::Durabiliby::High);\n    _ = <span class=\"hljs-title function_ invoke__\">tracked_fn</span>(&#x26;db, input); <span class=\"hljs-comment\">// panic</span>\n}\n</code></pre>\n<p>这个例子的和上一个的区别是，我们并没有在创造 tracked struct 的 query 中使用\ntracked struct 的 fields，但是我们间接在 query 依赖的其他 query 中使用了它的\nfields。回到这个例子，<code>tracked_fn(db, input)</code> 这个 query 创造了 <code>tracked</code> 这一\ntracked struct，但是</p>","title":"(WIP) Salsa: Is the tracked struct valid?","date":"2022-09-26"}},"__N_SSG":true}