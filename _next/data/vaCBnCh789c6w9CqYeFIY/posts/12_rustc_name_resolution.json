{"pageProps":{"postData":{"id":"12_rustc_name_resolution","contentHtml":"<p>先吐槽一下，原本前两天 <a href=\"https://rust-lang.github.io/rustc-reading-club/meetings/2021-11-04.html\">rustc reading\nclub</a>\n有个关于 name resolution 源码阅读的直播，但直播时发现 zoom 最多只能容纳 100 人，主讲人进不来了。他们也没有想到会有这么多人，最终是取消了这次活动。</p>\n<p>虽然活动没了，但 rustc 还是要学的。这不是一篇源码阅读，全文不涉及任何 rustc 的代码，因为我压根儿没怎么看\n<a href=\"https://github.com/rust-lang/rust/tree/master/compiler/rustc_resolve/src\">rustc_resolve</a>\n的代码，倒是看了一些 rust-analyzer 中 name resolution 的代码。这几天看 rust 开发文档，RFC 以及 rust-analyzer，本文是对 name resolution 的一个总结。</p>\n<h2>什么是 name resolution?</h2>\n<p>在编译时，将 name 和 definition 匹配的过程。比如说下面这个例子，我们在 bar 这个函数中使用 foo 的时候 ，需要知道 foo 指代的是第一行 foo 函数。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>() { ... }\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>() { <span class=\"hljs-title function_ invoke__\">foo</span>(); }\n</code></pre>\n<h2>Namespace</h2>\n<p>怎么实现 name resolution 呢？能否定义一个 map，key 是 name，value 是 definition\n呢？现在的一个关键点是在同一 scope 下，name 是唯一的吗？很遗憾，在 rust 中，并不是</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>() { ... }\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">foo</span> { field: <span class=\"hljs-type\">u32</span> }\n</code></pre>\n<p>上述代码是合法的，可以同时有一个叫 foo 的函数，还有一个叫 foo 的 struct。函数 foo\n和 struct foo 并不在同一 namespace 下，函数 foo 属于 value namespace，而 struct\nfoo 属于 type namespace。除了 type 和 value namespace 之外，还有 macro、lifetime\n以及 label namespace， 如果想知道不同 namespace 下有哪些东西，可以参考 <a href=\"https://doc.rust-lang.org/nightly/reference/names/namespaces.html\">rust\nreference\nnamespace</a></p>\n<h2>Import</h2>\n<p>考虑 import 的话，会让问题变得复杂起来。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">mod</span> a {\n    <span class=\"hljs-keyword\">use</span> crate::b::foo;\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>() {}\n}\n\n<span class=\"hljs-keyword\">mod</span> b {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>() {}\n}\n</code></pre>\n<p>假设编译器从上往下开始 resolve，很快就会发现，mod a 中 import 了 mod b 中的东西，但是现在 mod b 还没有被 resolve，不知道 mod b 中定义了哪些东西，有没有定义\nfoo。第一反应是，当编译器 resolve 这个 import 的时候，先去把 mod b 给 resolve\n了，完事儿后在跑回来 resolve 这个 import 的。听起来很合理，但考虑下面这个情形呢？</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">mod</span> a {\n    <span class=\"hljs-keyword\">use</span> crate::b::foo;\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>() {}\n}\n\n<span class=\"hljs-keyword\">mod</span> b {\n    <span class=\"hljs-keyword\">use</span> crate::a::bar;\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>() {}\n}\n</code></pre>\n<p>在 mod a 中 import mod b，mod b 中又 import 了 mod a。编译器 name resolution 的过程是 a-->b-->a-->b-->......，会进入一个死循环。</p>\n<p>怎么解决这个问题呢？碰到 import，可以先跳过。第一遍尽可能的去 resolve，如果\nimport 无法 resolve，就把它放到一个 working list 中。然后遍历 working list，尝试去 resolve 它们，如果 resolve 完成，就把它踢出 working list。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">mod</span> a {\n    <span class=\"hljs-keyword\">use</span> crate::b::bar;\n}\n\n<span class=\"hljs-keyword\">mod</span> b {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">use</span> crate::c::bar;\n}\n\n<span class=\"hljs-keyword\">mod</span> c {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>() {}\n}\n</code></pre>\n<p>working list 可能要遍历多次，考虑上面这个例子，第一轮 resolve 后，会得到一个包含\n<code>use crate::b::bar</code>, <code>use crate::c::bar</code> 的 working list，遍历 working list，先去 resolve <code>use crate::b::bar</code>，但 resolve 它依赖 <code>use crate::c::bar</code> 先\nresolve。所以第一次遍历 working list 后还会剩下 <code>use crate::b::bar</code>，再遍历一次才能完成所有的 name resolution。当然，也有可能 working list 无法清空，比如 mod c\n中并没有定义 bar 函数。这个方法的核心思想就是不断遍历 working list，直到 working\nlist 的长度不变，如果 working list 为空，那就说明 name resolution 成功，反之则说明代码有问题。</p>\n<h2>Macro</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-built_in\">macro_rules!</span> strukt {\n    ($i:ident) => {\n        <span class=\"hljs-keyword\">struct</span> $i { field: <span class=\"hljs-type\">u32</span> }\n    }\n}\nstrukt!(Foo);\nstrukts!(Foo) 做 <span class=\"hljs-keyword\">macro</span> expansion 会定义一个叫 Foo 的 <span class=\"hljs-keyword\">struct</span>\n\n<span class=\"hljs-title class_\">struct</span> Foo {\n    field: <span class=\"hljs-type\">u32</span>\n}\n</code></pre>\n<p>在生成 AST 的时候并没有做 macro expansion，在 rust-analyzer 中，<code>strukt!(Foo)</code>\n对应的 node 如下</p>\n<pre><code>  MACRO_CALL@176..189\n    PATH@176..182\n      PATH_SEGMENT@176..182\n        NAME_REF@176..182\n          IDENT@176..182 \"strukt\"\n    BANG@182..183 \"!\"\n    TOKEN_TREE@183..188\n      L_PAREN@183..184 \"(\"\n      IDENT@184..187 \"Foo\"\n      R_PAREN@187..188 \")\"\n    SEMICOLON@188..189 \";\"\n</code></pre>\n<p>macro expansion 发生在 name resolution 中，处理的方式和 import 类似，遇到还不能\nresolve 的 macro，就先把它放到 working list 中。比如说 macro 是 import 来的，或者这个 macro 依赖于另一个 macro，下面这个例子中，<code>strukt!(Foo)</code> 完全 exapnd 之前，<code>field_type!()</code> 得先 expand。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-built_in\">macro_rules!</span> field_type {\n    () => {\n        <span class=\"hljs-type\">u64</span>\n    };\n}\n\n<span class=\"hljs-built_in\">macro_rules!</span> strukt {\n    ($i:ident) => {\n        <span class=\"hljs-keyword\">struct</span> $i {\n            field: field_type!(),\n        }\n    };\n}\n\nstrukt!(Foo);\n</code></pre>\n<p>rust 中的 name resolution 还有很多细节我没有讨论，其实我也不清楚，但大多对我来说也算 corner case，现在也不想了解。</p>\n<h2>参考资料</h2>\n<p><a href=\"https://rustc-dev-guide.rust-lang.org/name-resolution.html#name-resolution\">rustc dev guide: name resolution</a></p>\n<p><a href=\"https://rust-lang.github.io/rfcs/1560-name-resolution.html\">RFC 1560: name resolution</a></p>\n<p><a href=\"https://doc.rust-lang.org/stable/reference/names/namespaces.html\">rust reference: namespace</a></p>\n<p><a href=\"https://willcrichton.net/notes/specificity-programming-languages/\">\"Do What I Mean\": Name Resolution in Programming Languages</a></p>","title":"rustc 如何做 name resolution","date":"2021-11-06"}},"__N_SSG":true}