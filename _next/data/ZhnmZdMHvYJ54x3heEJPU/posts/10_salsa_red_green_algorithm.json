{"pageProps":{"postData":{"id":"10_salsa_red_green_algorithm","contentHtml":"<p>我第一次听说 Salsa，第一次听说增量计算（incremental computation）的时候，就有一个疑问：这和 Python 中的 <a href=\"https://docs.python.org/3/library/functools.html#functools.cache\"><code>functools.cache</code></a> 有什么区别？</p>\n<p>现在我对 Salsa 更熟悉了，再次面对这个问题的时候，仍然不能很好地回答这个问题，但也有些想法，先记录下来。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">func</span>(input: Input) <span class=\"hljs-punctuation\">-></span> Output {\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    ...\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">output1</span> = <span class=\"hljs-title function_ invoke__\">func</span>(input)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">output2</span> = <span class=\"hljs-title function_ invoke__\">func</span>(input) <span class=\"hljs-comment\">// do not need to execute func again</span>\n}\n</code></pre>\n<p>输入同样的 <code>input</code>，第二次调用 <code>func</code> 时，可以直接从缓存中读取结果，而不需要再次执行 <code>func</code>。对于每一个不同的 <code>input</code>，保存之前的计算结果，下次调用时先查找数据库，没有找到才执行计算，Python 中的 <code>functools.cache</code> 就是这么做的。当然，还可以使用一些缓存替换策略，比如 LRU， Python 中 <a href=\"https://docs.python.org/3/library/functools.html#functools.lru_cache\"><code>functools.lru_cache</code></a> 就是这么做的。</p>\n<p>Salsa 是这么做的吗？显然不是。至少 Salsa 使用起来要比 <code>functools.cache</code> 复杂得多 ^_^。</p>\n<p>我能明显感觉到，Salsa 和 <code>functools.cache</code> 是有很大区别的，但这个区别到底是什么，我好像又说不清楚。。。我好像有点思路，我尝试捋一捋</p>\n<p>Salsa 想解决的问题，或者说适用的场景并不是我上面伪代码所示的，而应该像这样</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">input</span> = ...;\n    <span class=\"hljs-keyword\">loop</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">output</span> = <span class=\"hljs-title function_ invoke__\">your_program</span>(&#x26;input);\n        <span class=\"hljs-title function_ invoke__\">modify</span>(&#x26;<span class=\"hljs-keyword\">mut</span> input);\n    }\n}\n</code></pre>\n<blockquote>\n<p>You start out with an input that has some value. You invoke your program to get back a result. Some time later, you modify the input and invoke your program again. Our goal is to make this second call faster by re-using some of the results from the first call.<br>\n-- <a href=\"https://salsa-rs.netlify.app/overview.html#goal-of-salsa\">https://salsa-rs.netlify.app/overview.html#goal-of-salsa</a></p>\n</blockquote>\n<p>一个重要的点是，我们是在 loop 之中不断修改 <code>input</code>。如果换做 <code>functools.cache</code>，它解决的问题应该是</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">input0</span> = ...;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">output</span> = <span class=\"hljs-title function_ invoke__\">your_program</span>(&#x26;input0);\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">input1</span> = ...;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">output</span> = <span class=\"hljs-title function_ invoke__\">your_program</span>(&#x26;input1);\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">input2</span> = ...;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">output</span> = <span class=\"hljs-title function_ invoke__\">your_program</span>(&#x26;input2);\n\n    ...\n}\n</code></pre>\n<p>Salsa 强调的是 <code>input</code> change，而 <code>functools.cache</code> 是没有 <code>input</code> change 的，只有不同的 <code>input</code>。</p>\n<p>另一方面，在 <code>functools.cache</code> 中，每个 <code>input</code> 地位是同等的</p>\n<p><img src=\"/10/input-output.png\" alt=\"\">\n<img src=\"../public/10/input-output.png\" alt=\"\"></p>\n<p>而对 Salsa 来说，一个 <code>input</code> 如果发生了改变，那么它之前的版本就没有用了，所有为旧 <code>input</code> 保存的计算结果都可以丢弃了。Salsa 系统中，是没有太大的存储压力的，这一点和 <code>functools.cache</code> 是非常不一样的，完全可以以 Salsa 为核心写一个复杂软件，比如 <code>rust-analyzer</code>，但无法想象以 <code>functools.cache</code> 为核心构造一个软件。</p>\n<p><img src=\"/10/input-version.png\" alt=\"\">\n<img src=\"../public/10/input-version.png\" alt=\"\"></p>","title":"Salsa 和 functools.cache 有什么不同？","date":"2022-12-15"}},"__N_SSG":true}