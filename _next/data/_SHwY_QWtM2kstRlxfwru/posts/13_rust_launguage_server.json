{"pageProps":{"postData":{"id":"13_rust_launguage_server","contentHtml":"<p>标题听起来像是一个教程，但它真的只是一个问题，是我问自己的一个问题，这篇文章记录我初步的思考。</p>\n<p>先说说为什么会有这个问题吧，我觉得还挺有意思的。最近在看 <a href=\"https://github.com/rust-lang/rust-analyzer\">RA（Rust\nAnalyzer）</a> 的源码，对 RA 的整体架构有了基本的认识，也提过一些 pr，但不知道接下来该怎么深入，迷茫之际，脑袋里突然蹦出这么一个问题：如果我去实现一个 Rust LS（languageserver），该怎么设计呢？</p>\n<h2>如何实现</h2>\n<p>实现一个 Rust LS。太复杂了，包括代码高亮、自动补全、定义跳转、Find Usages。</p>\n<p>实现一个只有自动补全功能的 LS。再简化下，把自动补全功能限制在单个 rust 文件中，\n也就是不考虑 workspace 中有多个 crate，甚至多个文件的情况。</p>\n<p>实现一个能在单个 rust 文件中自动补全的 LS。自动补全些什么呢？对 rust 来说，要补全 keyword、built-in type、function、struct、trait、macro、attribute。太多了，不如把自动补全限制在 keyword、built-in type 以及用户自定义的 function 和 struct\n上。</p>\n<p>别管是通过磁盘 IO 读取 rust 文件还是 client 发送给我们，我们的输入就是一个字符串。</p>\n<p>最后，再把问题明确一下，输入是一个字符串，包含 rust 代码以及一个表示光标所在位置的符号，输出是自动补全的建议，只针对 keyword、build-in type 以及用户自定义\nfunction 和 struct。</p>\n<pre><code class=\"hljs language-vbnet\"><span class=\"hljs-symbol\">Inputs:</span>\nst$<span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-symbol\">Suggestions:</span>\nstruct\n<span class=\"hljs-keyword\">static</span>\n</code></pre>\n<p>上面的例子是说输入是“st$0”，“st”是 rust 代码，“$0”表示光标位置，意思是当键盘敲击\n“st”时，应该补全为“struct”或者“static”。</p>\n<h2>如何实现</h2>\n<p>keyword 和 built-in type 比较容易，建个 hash 表，字符串匹配就行，那对于 function\n和 struct 呢？也能用字符串匹配吗？</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Foo</span>;\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Foo</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">f</span> = Foo;\n    f.$<span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<p>对于上述情况，字符串匹配应该匹配啥呢？</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//foo.rs</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Foo</span>;\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Foo</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-keyword\">self</span>) {}\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">baz</span>(<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-comment\">//main.rs</span>\n<span class=\"hljs-keyword\">mod</span> foo;\n<span class=\"hljs-keyword\">use</span> foo::Foo;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">f</span> = Foo;\n    f.$<span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<p>这里应该建议补全 f.baz 吗？baz 作为一个私有方法，在 main.rs 中是没有权限访问的\n（虽然在上一节限制了只考虑单个文件，但这里还是想提一下）。在 RA 中会给出补全\nf.bar 和 f.baz 的建议，补全后会给出\"associated function baz is private\"的\nerror。也不知道这是个 bug，还是故意这么设计的。但无关紧要，这里想说的是，字符串匹配不足以实现自动补全。通过上面的例子，实现自动补全似乎需要知道 f 是一个\nstruct，该 struct 有哪些方法，哪些 field？甚至每个方法，每个 field 的\nvisibility。</p>\n<p>如果我们有了 AST，能完成自动补全吗？</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Foo</span> {\n    first: <span class=\"hljs-type\">i32</span>,\n    second: <span class=\"hljs-type\">String</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Foo</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-keyword\">self</span>) {}\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">baz</span>(<span class=\"hljs-keyword\">self</span>) {}\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">foo</span> = Foo {\n        first: <span class=\"hljs-number\">0</span>,\n        second: <span class=\"hljs-type\">String</span>::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"hello\"</span>),\n    };\n    foo.$<span class=\"hljs-number\">0</span>\n}\n</code></pre>\n<p>假设上述代码的 AST 如下</p>\n<p><img src=\"/13/ast.png\" alt=\"\"></p>\n<p>AST 已经有足够的信息去做 struct 的自动补全，遍历 AST 可以知道 foo 是一个 Struct\nFoo，再遍历 AST 可以知道 Foo 有哪些 field，哪些 method。最终给出自动补全的建议</p>\n<pre><code class=\"hljs language-scss\">first\nsecond\n<span class=\"hljs-built_in\">bar</span>()\n<span class=\"hljs-built_in\">baz</span>()\n</code></pre>\n<p>Rust Analyzer 是怎么做的？RA 的做法和我上面说的没有本质不同，下面简单聊聊 RA 中额外的东西</p>\n<blockquote>\n<p>2022.12.17：今天再读，感觉 “RA 的做法和我上面说的没有本质不同” 这个结论是有很大问题的，RA 做了编译器前端需要做的一切事情，包括 name resolution，type check\n等等</p>\n</blockquote>\n<h3>易用性</h3>\n<p>首先是为了易用性，RA 在 AST 上再包了一层。怎么理解呢，假设 AST 中非叶子节点的定义是</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\n    kind: Kind,\n    text: <span class=\"hljs-type\">String</span>,\n    children: <span class=\"hljs-type\">Vec</span>&#x3C;Either&#x3C;Node, Token>>\n}\n</code></pre>\n<p>对于 Foo</p>\n<pre><code class=\"hljs language-arduino\">Node { kind: Kind::Struct, text: <span class=\"hljs-string\">\"Foo\"</span>.<span class=\"hljs-built_in\">to_string</span>(), children: vec![first, second, bar, baz] }\n</code></pre>\n<p>无论是一个 struct，还是一个 function，又或者是一个 trait，在 AST 中它们都只是\nNode，类型是相同的，要得到 struct 的 field、method，或是得到 function 的\nparameter、return type 都只能通过遍历 children。</p>\n<p>对于 struct，RA 定义了类似下面的数据类型</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Struct</span> {\n    node: Node\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Struct</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fields</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Iterator</span>&#x3C;Item = Field> {} \n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">first_field</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> Field {} \n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">methods</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Iterator</span>&#x3C;Item = Method> {}\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">first_method</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> Method {}\n    ...\n}\n</code></pre>\n<p>把 Foo 对应的 Node 转换成一个 Struct，对一个 Struct 操作比对一个 Node 操作要方便的多。</p>\n<h3>性能优化</h3>\n<p>每次找一个 node 都需要遍历 AST 吗？在 IDE 中敲代码，每个小改动都要重新分析一遍所有代码吗？</p>\n<p>事实是大多数的改动都非常小，我们之前的一些计算结果并不需要抛弃。得益于 salsa\n，RA 实现了增量计算，对于 salsa 的细节，我也搞不清楚，<a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/guide.md#salsa\">https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/guide.md#salsa</a>\nhigh level 的讲了 salsa 是如何工作的。</p>\n<p>之后应该会去研究一下 salsa，再来分享</p>","title":"如何实现一个Rust Language Server?","date":"2021-10-24"}},"__N_SSG":true}